#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

#define MAX_FILES 1000
#define MAX_FILENAME 256
#define BUFFER_SIZE 1024

typedef struct {
    char filename[MAX_FILENAME];
    long size;
    time_t modified_time;
    char hash[33]; // MD5 hash
} FileInfo;

typedef struct {
    FileInfo files_before[MAX_FILES];
    FileInfo files_after[MAX_FILES];
    int file_count_before;
    int file_count_after;
} SystemSnapshot;

// Simple MD5 hash function (simplified for demonstration)
void calculate_md5(const char* filename, char* output) {
    // In real implementation, use proper MD5 calculation
    // This is a simplified version for demonstration
    FILE* file = fopen(filename, "rb");
    if (file) {
        // Simple hash simulation
        sprintf(output, "simulated_md5_hash_%s", filename);
        fclose(file);
    } else {
        strcpy(output, "N/A");
    }
}

void get_file_list(const char* directory, FileInfo* files, int* count) {
    DIR* dir;
    struct dirent* entry;
    struct stat file_stat;
    char full_path[MAX_FILENAME];
    
    dir = opendir(directory);
    if (dir == NULL) {
        return;
    }
    
    while ((entry = readdir(dir)) != NULL && *count < MAX_FILES) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        
        snprintf(full_path, sizeof(full_path), "%s/%s", directory, entry->d_name);
        
        if (stat(full_path, &file_stat) == 0) {
            if (S_ISREG(file_stat.st_mode)) {
                strcpy(files[*count].filename, full_path);
                files[*count].size = file_stat.st_size;
                files[*count].modified_time = file_stat.st_mtime;
                calculate_md5(full_path, files[*count].hash);
                (*count)++;
            }
        }
    }
    
    closedir(dir);
}

void take_snapshot(SystemSnapshot* snapshot, const char* monitor_dir) {
    snapshot->file_count_before = 0;
    get_file_list(monitor_dir, snapshot->files_before, &snapshot->file_count_before);
}

void compare_snapshots(SystemSnapshot* before, SystemSnapshot* after, const char* output_file) {
    FILE* output = fopen(output_file, "w");
    if (!output) {
        printf("Error creating output file\n");
        return;
    }
    
    fprintf(output, "MALWARE BEHAVIOR ANALYSIS - IOC REPORT\n");
    fprintf(output, "======================================\n\n");
    
    // Find new files
    fprintf(output, "NEW FILES CREATED:\n");
    fprintf(output, "------------------\n");
    
    for (int i = 0; i < after->file_count_after; i++) {
        int found = 0;
        for (int j = 0; j < before->file_count_before; j++) {
            if (strcmp(after->files_after[i].filename, before->files_before[j].filename) == 0) {
                found = 1;
                break;
            }
        }
        
        if (!found) {
            fprintf(output, "File: %s\n", after->files_after[i].filename);
            fprintf(output, "Size: %ld bytes\n", after->files_after[i].size);
            fprintf(output, "Hash: %s\n", after->files_after[i].hash);
            fprintf(output, "Modified: %s", ctime(&after->files_after[i].modified_time));
            fprintf(output, "---\n");
        }
    }
    
    fclose(output);
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        printf("Usage: %s <malware_sample> <monitor_directory>\n", argv[0]);
        printf("Example: %s ./suspicious_file.exe /tmp\n", argv[0]);
        return 1;
    }
    
    char* malware_sample = argv[1];
    char* monitor_dir = argv[2];
    
    SystemSnapshot snapshot;
    
    printf("Taking initial system snapshot...\n");
    take_snapshot(&snapshot, monitor_dir);
    
    printf("Executing malware sample: %s\n", malware_sample);
    printf("WARNING: This will execute potentially malicious code!\n");
    printf("Press Enter to continue...");
    getchar();
    
    // Execute the sample (simplified)
    char command[512];
    snprintf(command, sizeof(command), "./%s &", malware_sample);
    system(command);
    
    printf("Waiting for malware execution...\n");
    sleep(10); // Wait for 10 seconds
    
    printf("Taking final system snapshot...\n");
    snapshot.file_count_after = 0;
    get_file_list(monitor_dir, snapshot.files_after, &snapshot.file_count_after);
    
    printf("Generating IOC report...\n");
    compare_snapshots(&snapshot, &snapshot, "ioc_report.txt");
    
    printf("Analysis complete! Check ioc_report.txt for results.\n");
    
    return 0;
}
