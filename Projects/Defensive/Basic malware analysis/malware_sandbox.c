/**
 * Basic Malware Analysis Sandbox - C Implementation
 * Compile: gcc -o malware_sandbox malware_sandbox.c -lssl -lcrypto
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>
#include <dirent.h>
#include <openssl/md5.h>
#include <openssl/sha.h>

#define MAX_PATH 1024
#define MAX_PROCESSES 100
#define MAX_CONNECTIONS 50
#define MAX_STRINGS 1000
#define ANALYSIS_TIMEOUT 60

typedef struct {
    char filename[MAX_PATH];
    long file_size;
    char file_type[256];
    char md5[33];
    char sha1[41];
    char sha256[65];
    double entropy;
    char timestamp[64];
} FileInfo;

typedef struct {
    int pid;
    char name[256];
    char cmdline[1024];
    double create_time;
    int parent_pid;
    char username[64];
    char timestamp[64];
} ProcessInfo;

typedef struct {
    int pid;
    char protocol[16];
    char local_address[64];
    char remote_address[64];
    char status[32];
    char timestamp[64];
} NetworkConnection;

typedef struct {
    char analysis_id[32];
    FileInfo file_info;
    ProcessInfo processes[MAX_PROCESSES];
    int process_count;
    NetworkConnection connections[MAX_CONNECTIONS];
    int connection_count;
    char verdict[32];
    int score;
    char reasons[10][256];
    int reason_count;
} AnalysisReport;

void generate_analysis_id(char* buffer, size_t size) {
    time_t now = time(NULL);
    unsigned long seed = (unsigned long)now ^ (unsigned long)getpid();
    snprintf(buffer, size, "AN%08lx", seed);
}

void calculate_md5(const char* filename, char* output) {
    FILE* file = fopen(filename, "rb");
    if(!file) {
        strcpy(output, "Error");
        return;
    }
    
    MD5_CTX md5Context;
    MD5_Init(&md5Context);
    
    unsigned char buffer[1024];
    int bytesRead;
    while((bytesRead = fread(buffer, 1, 1024, file)) != 0) {
        MD5_Update(&md5Context, buffer, bytesRead);
    }
    
    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5_Final(digest, &md5Context);
    
    for(int i = 0; i < MD5_DIGEST_LENGTH; i++) {
        sprintf(output + (i * 2), "%02x", digest[i]);
    }
    output[MD5_DIGEST_LENGTH * 2] = '\0';
    
    fclose(file);
}

void calculate_sha256(const char* filename, char* output) {
    FILE* file = fopen(filename, "rb");
    if(!file) {
        strcpy(output, "Error");
        return;
    }
    
    SHA256_CTX sha256Context;
    SHA256_Init(&sha256Context);
    
    unsigned char buffer[1024];
    int bytesRead;
    while((bytesRead = fread(buffer, 1, 1024, file)) != 0) {
        SHA256_Update(&sha256Context, buffer, bytesRead);
    }
    
    unsigned char digest[SHA256_DIGEST_LENGTH];
    SHA256_Final(digest, &sha256Context);
    
    for(int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output + (i * 2), "%02x", digest[i]);
    }
    output[SHA256_DIGEST_LENGTH * 2] = '\0';
    
    fclose(file);
}

double calculate_entropy(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if(!file) return 0.0;
    
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    if(file_size == 0) {
        fclose(file);
        return 0.0;
    }
    
    unsigned char* buffer = malloc(file_size);
    if(!buffer) {
        fclose(file);
        return 0.0;
    }
    
    fread(buffer, 1, file_size, file);
    fclose(file);
    
    int frequency[256] = {0};
    for(long i = 0; i < file_size; i++) {
        frequency[buffer[i]]++;
    }
    
    double entropy = 0.0;
    for(int i = 0; i < 256; i++) {
        if(frequency[i] > 0) {
            double probability = (double)frequency[i] / file_size;
            entropy -= probability * (__builtin_popcount(frequency[i]) - 1);
        }
    }
    
    free(buffer);
    return entropy;
}

void get_file_info(const char* filename, FileInfo* file_info) {
    struct stat st;
    if(stat(filename, &st) != 0) {
        perror("stat");
        return;
    }
    
    strcpy(file_info->filename, filename);
    file_info->file_size = st.st_size;
    
    // Simple file type detection
    if(strstr(filename, ".exe")) {
        strcpy(file_info->file_type, "Windows Executable");
    } else if(strstr(filename, ".py")) {
        strcpy(file_info->file_type, "Python Script");
    } else {
        strcpy(file_info->file_type, "Unknown");
    }
    
    calculate_md5(filename, file_info->md5);
    calculate_sha256(filename, file_info->sha256);
    file_info->entropy = calculate_entropy(filename);
    
    time_t now = time(NULL);
    strcpy(file_info->timestamp, ctime(&now));
    file_info->timestamp[strlen(file_info->timestamp)-1] = '\0'; // Remove newline
}

int monitor_processes(ProcessInfo* processes, int max_processes) {
    // Simulated process monitoring
    int count = 3;
    
    processes[0] = (ProcessInfo){1884, "notepad.exe", "notepad.exe secret.txt", 1700000000.0, 264, "user1", "2024-01-15T10:30:15"};
    processes[1] = (ProcessInfo){1922, "suspicious.exe", "suspicious.exe -stealth", 1700000000.0, 1884, "user1", "2024-01-15T10:31:22"};
    processes[2] = (ProcessInfo){2001, "cmd.exe", "cmd.exe /c whoami", 1700000000.0, 1922, "user1", "2024-01-15T10:32:00"};
    
    return count;
}

int monitor_network(NetworkConnection* connections, int max_connections) {
    // Simulated network monitoring
    int count = 2;
    
    connections[0] = (NetworkConnection){1922, "TCP", "192.168.1.100:49215", "45.33.32.156:443", "ESTABLISHED", "2024-01-15T10:31:25"};
    connections[1] = (NetworkConnection){984, "UDP", "192.168.1.100:53", "8.8.8.8:53", "LISTENING", "2024-01-15T10:30:00"};
    
    return count;
}

void execute_sample(const char* sample_path, int timeout) {
    printf("[*] Executing sample: %s\n", sample_path);
    printf("[*] Timeout: %d seconds\n", timeout);
    
    pid_t pid = fork();
    if(pid == 0) {
        // Child process - execute the sample
        if(strstr(sample_path, ".py")) {
            execlp("python3", "python3", sample_path, NULL);
        } else {
            // For other files, try to make executable and run
            chmod(sample_path, 0755);
            execl(sample_path, sample_path, NULL);
        }
        perror("execl");
        exit(1);
    } else if(pid > 0) {
        // Parent process - wait with timeout
        int status;
        time_t start_time = time(NULL);
        
        while(1) {
            pid_t result = waitpid(pid, &status, WNOHANG);
            if(result == -1) {
                perror("waitpid");
                break;
            } else if(result == 0) {
                // Process still running
                if(time(NULL) - start_time > timeout) {
                    printf("[-] Process timeout - terminating\n");
                    kill(pid, SIGKILL);
                    waitpid(pid, &status, 0);
                    break;
                }
                sleep(1);
            } else {
                // Process finished
                printf("[+] Process completed with status: %d\n", status);
                break;
            }
        }
    } else {
        perror("fork");
    }
}

void generate_verdict(AnalysisReport* report) {
    int score = 0;
    report->reason_count = 0;
    
    // Analyze processes
    for(int i = 0; i < report->process_count; i++) {
        if(strstr(report->processes[i].name, "suspicious")) {
            score += 30;
            strcpy(report->reasons[report->reason_count++], "Suspicious process name");
        }
        if(strstr(report->processes[i].name, "cmd.exe")) {
            score += 20;
            strcpy(report->reasons[report->reason_count++], "Command interpreter usage");
        }
    }
    
    // Analyze network connections
    for(int i = 0; i < report->connection_count; i++) {
        if(strstr(report->connections[i].remote_address, "45.33.32.156")) {
            score += 25;
            strcpy(report->reasons[report->reason_count++], "Connection to suspicious IP");
        }
    }
    
    // Analyze file entropy
    if(report->file_info.entropy > 7.0) {
        score += 15;
        strcpy(report->reasons[report->reason_count++], "High file entropy (possible encryption/packing)");
    }
    
    report->score = score;
    
    if(score >= 70) {
        strcpy(report->verdict, "MALICIOUS");
    } else if(score >= 40) {
        strcpy(report->verdict, "SUSPICIOUS");
    } else {
        strcpy(report->verdict, "CLEAN");
    }
}

void print_report(const AnalysisReport* report) {
    printf("\n=== MALWARE ANALYSIS REPORT ===\n\n");
    
    printf("Analysis ID: %s\n", report->analysis_id);
    printf("Timestamp: %s\n\n", report->file_info.timestamp);
    
    printf("FILE INFORMATION:\n");
    printf("  Filename: %s\n", report->file_info.filename);
    printf("  Size: %ld bytes\n", report->file_info.file_size);
    printf("  Type: %s\n", report->file_info.file_type);
    printf("  MD5: %s\n", report->file_info.md5);
    printf("  SHA256: %s\n", report->file_info.sha256);
    printf("  Entropy: %.4f\n\n", report->file_info.entropy);
    
    printf("BEHAVIORAL ANALYSIS:\n");
    printf("  Processes Created: %d\n", report->process_count);
    for(int i = 0; i < report->process_count; i++) {
        printf("    %d. %s (PID: %d) -> %s\n", 
               i+1, report->processes[i].name, report->processes[i].pid,
               report->processes[i].cmdline);
    }
    
    printf("\n  Network Connections: %d\n", report->connection_count);
    for(int i = 0; i < report->connection_count; i++) {
        printf("    %d. %s %s -> %s (%s) PID: %d\n",
               i+1, report->connections[i].protocol,
               report->connections[i].local_address,
               report->connections[i].remote_address,
               report->connections[i].status,
               report->connections[i].pid);
    }
    
    printf("\nVERDICT:\n");
    printf("  Result: %s\n", report->verdict);
    printf("  Score: %d/100\n", report->score);
    printf("  Reasons:\n");
    for(int i = 0; i < report->reason_count; i++) {
        printf("    - %s\n", report->reasons[i]);
    }
}

int main(int argc, char* argv[]) {
    if(argc < 2) {
        printf("Basic Malware Analysis Sandbox\n");
        printf("Usage: %s <malware_sample> [timeout_seconds]\n", argv[0]);
        return 1;
    }
    
    const char* sample_path = argv[1];
    int timeout = ANALYSIS_TIMEOUT;
    
    if(argc > 2) {
        timeout = atoi(argv[2]);
    }
    
    if(access(sample_path, F_OK) != 0) {
        printf("Error: Sample file '%s' not found\n", sample_path);
        return 1;
    }
    
    printf("[*] Starting malware analysis sandbox\n");
    printf("[*] Sample: %s\n", sample_path);
    
    // Initialize analysis report
    AnalysisReport report;
    generate_analysis_id(report.analysis_id, sizeof(report.analysis_id));
    
    // Pre-execution analysis
    printf("[*] Performing pre-execution analysis\n");
    get_file_info(sample_path, &report.file_info);
    
    // Execute sample with monitoring
    printf("[*] Starting execution and monitoring\n");
    execute_sample(sample_path, timeout);
    
    // Post-execution analysis
    printf("[*] Performing post-execution analysis\n");
    report.process_count = monitor_processes(report.processes, MAX_PROCESSES);
    report.connection_count = monitor_network(report.connections, MAX_CONNECTIONS);
    
    // Generate verdict
    generate_verdict(&report);
    
    // Print report
    print_report(&report);
    
    printf("\n[*] Analysis completed\n");
    return 0;
}
