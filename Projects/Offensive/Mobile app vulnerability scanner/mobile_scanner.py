#!/usr/bin/env python3
"""
Mobile App Vulnerability Scanner
Purpose: Perform static and dynamic analysis of mobile applications
Use: Security assessment, vulnerability discovery, compliance testing
"""

import os
import re
import json
import zipfile
import subprocess
import threading
import time
import argparse
from pathlib import Path
from datetime import datetime
from collections import defaultdict
import xml.etree.ElementTree as ET
import hashlib

class MobileAppScanner:
    def __init__(self, app_path):
        self.app_path = app_path
        self.app_type = None
        self.temp_dir = "/tmp/mobile_scan"
        self.results = {
            'metadata': {},
            'static_analysis': {},
            'dynamic_analysis': {},
            'vulnerabilities': [],
            'security_score': 0
        }
        
    def detect_app_type(self):
        """Detect if the app is Android APK or iOS IPA"""
        if self.app_path.endswith('.apk'):
            self.app_type = 'android'
        elif self.app_path.endswith('.ipa'):
            self.app_type = 'ios'
        else:
            # Try to determine by file signature
            with open(self.app_path, 'rb') as f:
                header = f.read(8)
                if header.startswith(b'PK'):
                    self.app_type = 'android'  # APK is ZIP-based
                else:
                    raise ValueError("Unsupported app format")
        return self.app_type
    
    def extract_app(self):
        """Extract app contents for analysis"""
        os.makedirs(self.temp_dir, exist_ok=True)
        
        if self.app_type == 'android':
            with zipfile.ZipFile(self.app_path, 'r') as zip_ref:
                zip_ref.extractall(self.temp_dir)
        elif self.app_type == 'ios':
            # IPA is also ZIP-based
            with zipfile.ZipFile(self.app_path, 'r') as zip_ref:
                zip_ref.extractall(self.temp_dir)
        
        print(f"[EXTRACT] App extracted to {self.temp_dir}")
    
    def static_analysis_android(self):
        """Perform static analysis on Android APK"""
        print("[STATIC] Starting Android static analysis...")
        
        # Basic APK structure analysis
        apk_structure = self.analyze_apk_structure()
        self.results['static_analysis']['apk_structure'] = apk_structure
        
        # Manifest analysis
        manifest_issues = self.analyze_android_manifest()
        self.results['static_analysis']['manifest_analysis'] = manifest_issues
        
        # Code analysis
        code_issues = self.analyze_android_code()
        self.results['static_analysis']['code_analysis'] = code_issues
        
        # Permission analysis
        permission_issues = self.analyze_permissions()
        self.results['static_analysis']['permission_analysis'] = permission_issues
        
        # Hardcoded secrets
        secrets = self.search_hardcoded_secrets()
        self.results['static_analysis']['hardcoded_secrets'] = secrets
        
        return self.results['static_analysis']
    
    def analyze_apk_structure(self):
        """Analyze APK file structure"""
        structure = {
            'has_dex': False,
            'has_resources': False,
            'has_native_libs': False,
            'has_manifest': False,
            'file_list': []
        }
        
        for root, dirs, files in os.walk(self.temp_dir):
            for file in files:
                file_path = os.path.join(root, file)
                structure['file_list'].append(file_path)
                
                if file.endswith('.dex'):
                    structure['has_dex'] = True
                elif file == 'AndroidManifest.xml':
                    structure['has_manifest'] = True
                elif file.endswith('.so'):
                    structure['has_native_libs'] = True
                elif 'res/' in file_path:
                    structure['has_resources'] = True
        
        return structure
    
    def analyze_android_manifest(self):
        """Analyze AndroidManifest.xml for security issues"""
        issues = []
        manifest_path = os.path.join(self.temp_dir, 'AndroidManifest.xml')
        
        if not os.path.exists(manifest_path):
            issues.append("AndroidManifest.xml not found")
            return issues
        
        try:
            # For proper parsing, we'd need AXMLParser or similar
            # This is a simplified analysis
            with open(manifest_path, 'rb') as f:
                content = f.read().decode('utf-8', errors='ignore')
            
            # Check for debuggable flag
            if 'android:debuggable="true"' in content:
                issues.append("App is debuggable - security risk")
            
            # Check for backup allowed
            if 'android:allowBackup="true"' in content:
                issues.append("App allows backup - potential data exposure")
            
            # Check for cleartext traffic
            if 'android:usesCleartextTraffic="true"' in content:
                issues.append("App allows cleartext traffic - security risk")
            
            # Extract package name
            package_match = re.search(r'package="([^"]+)"', content)
            if package_match:
                self.results['metadata']['package_name'] = package_match.group(1)
            
        except Exception as e:
            issues.append(f"Manifest analysis error: {str(e)}")
        
        return issues
    
    def analyze_permissions(self):
        """Analyze app permissions for security risks"""
        permissions_analysis = {
            'dangerous_permissions': [],
            'normal_permissions': [],
            'signature_permissions': [],
            'risky_combinations': []
        }
        
        # Common dangerous permissions
        dangerous_perms = [
            'READ_EXTERNAL_STORAGE',
            'WRITE_EXTERNAL_STORAGE', 
            'ACCESS_FINE_LOCATION',
            'ACCESS_COARSE_LOCATION',
            'READ_PHONE_STATE',
            'CALL_PHONE',
            'READ_SMS',
            'SEND_SMS',
            'CAMERA',
            'RECORD_AUDIO'
        ]
        
        manifest_path = os.path.join(self.temp_dir, 'AndroidManifest.xml')
        if os.path.exists(manifest_path):
            with open(manifest_path, 'rb') as f:
                content = f.read().decode('utf-8', errors='ignore')
            
            # Extract permissions
            permission_pattern = r'android:name="android\.permission\.([^"]+)"'
            permissions = re.findall(permission_pattern, content)
            
            for perm in permissions:
                if perm in dangerous_perms:
                    permissions_analysis['dangerous_permissions'].append(perm)
                else:
                    permissions_analysis['normal_permissions'].append(perm)
            
            # Check for risky permission combinations
            if 'ACCESS_FINE_LOCATION' in permissions and 'INTERNET' in permissions:
                permissions_analysis['risky_combinations'].append(
                    "Location data can be sent over internet")
        
        return permissions_analysis
    
    def analyze_android_code(self):
        """Analyze Android code for security issues"""
        code_issues = []
        
        # Search for suspicious code patterns in small files
        for root, dirs, files in os.walk(self.temp_dir):
            for file in files:
                if file.endswith(('.smali', '.xml', '.json', '.txt')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', errors='ignore') as f:
                            content = f.read()
                            
                            # Check for hardcoded URLs
                            url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
                            urls = re.findall(url_pattern, content)
                            if urls:
                                code_issues.append(f"Hardcoded URLs in {file}: {urls[:3]}")
                            
                            # Check for encryption issues
                            if 'MD5' in content or 'SHA-1' in content:
                                code_issues.append(f"Weak crypto in {file}")
                                
                            # Check for certificate pinning bypass
                            if 'TrustManager' in content and 'checkClientTrusted' in content:
                                if 'throw new CertificateException' not in content:
                                    code_issues.append(f"TrustManager vulnerability in {file}")
                    
                    except Exception:
                        continue
        
        return code_issues
    
    def search_hardcoded_secrets(self):
        """Search for hardcoded secrets in app resources"""
        secrets_found = []
        
        secret_patterns = {
            'api_key': r'[aA][pP][iI][_-]?[kK][eE][yY].*?[\'\"]([^\'\"]{10,50})[\'\"]',
            'password': r'[pP][aA][sS]{2}[wW][oO][rR][dD].*?[\'\"]([^\'\"]{3,50})[\'\"]',
            'secret': r'[sS][eE][cC][rR][eE][tT].*?[\'\"]([^\'\"]{10,50})[\'\"]',
            'token': r'[tT][oO][kK][eE][nN].*?[\'\"]([^\'\"]{10,100})[\'\"]',
        }
        
        for root, dirs, files in os.walk(self.temp_dir):
            for file in files:
                if file.endswith(('.xml', '.json', '.properties', '.config')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', errors='ignore') as f:
                            content = f.read()
                            
                            for secret_type, pattern in secret_patterns.items():
                                matches = re.findall(pattern, content)
                                for match in matches:
                                    if len(match) > 5:  # Basic length check
                                        secrets_found.append({
                                            'type': secret_type,
                                            'file': file,
                                            'value_preview': match[:20] + '...' if len(match) > 20 else match
                                        })
                    
                    except Exception:
                        continue
        
        return secrets_found
    
    def dynamic_analysis_android(self, device_id=None):
        """Perform dynamic analysis on Android app"""
        print("[DYNAMIC] Starting Android dynamic analysis...")
        
        dynamic_results = {
            'network_analysis': {},
            'runtime_behavior': {},
            'data_storage': {},
            'log_analysis': {}
        }
        
        # Check if ADB is available
        if not self.check_adb():
            print("ADB not available - skipping dynamic analysis")
            return dynamic_results
        
        # Install app on device/emulator
        if self.install_apk(device_id):
            # Run various dynamic tests
            dynamic_results['network_analysis'] = self.analyze_network_traffic(device_id)
            dynamic_results['runtime_behavior'] = self.monitor_runtime_behavior(device_id)
            dynamic_results['data_storage'] = self.analyze_data_storage(device_id)
            dynamic_results['log_analysis'] = self.analyze_logs(device_id)
            
            # Uninstall app
            self.uninstall_apk(device_id)
        
        return dynamic_results
    
    def check_adb(self):
        """Check if ADB is available"""
        try:
            result = subprocess.run(['adb', 'version'], 
                                  capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def install_apk(self, device_id=None):
        """Install APK on device/emulator"""
        try:
            cmd = ['adb']
            if device_id:
                cmd.extend(['-s', device_id])
            cmd.extend(['install', '-r', self.app_path])
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            if 'Success' in result.stdout:
                print("[DYNAMIC] APK installed successfully")
                return True
            else:
                print(f"[DYNAMIC] APK installation failed: {result.stdout}")
                return False
        except Exception as e:
            print(f"[DYNAMIC] Installation error: {e}")
            return False
    
    def uninstall_apk(self, device_id=None):
        """Uninstall APK from device"""
        if 'package_name' in self.results['metadata']:
            package = self.results['metadata']['package_name']
            try:
                cmd = ['adb']
                if device_id:
                    cmd.extend(['-s', device_id])
                cmd.extend(['uninstall', package])
                
                subprocess.run(cmd, capture_output=True)
                print("[DYNAMIC] APK uninstalled")
            except Exception as e:
                print(f"[DYNAMIC] Uninstall error: {e}")
    
    def analyze_network_traffic(self, device_id):
        """Analyze network traffic during app execution"""
        network_analysis = {
            'cleartext_traffic': [],
            'suspicious_domains': [],
            'data_leakage': []
        }
        
        # This would require running the app and capturing traffic
        # Simplified implementation
        print("  [NETWORK] Network analysis would require traffic capture setup")
        
        return network_analysis
    
    def monitor_runtime_behavior(self, device_id):
        """Monitor app behavior during runtime"""
        behavior_analysis = {
            'permission_usage': [],
            'file_access': [],
            'suspicious_activities': []
        }
        
        # Monitor using ADB commands
        try:
            # Check running services
            cmd = ['adb', 'shell', 'dumpsys', 'activity', 'services']
            result = subprocess.run(cmd, capture_output=True, text=True)
            behavior_analysis['running_services'] = result.stdout[:500] + "..."
            
        except Exception as e:
            print(f"  [BEHAVIOR] Monitoring error: {e}")
        
        return behavior_analysis
    
    def analyze_data_storage(self, device_id):
        """Analyze how app stores data"""
        storage_analysis = {
            'shared_prefs': [],
            'database_files': [],
            'external_storage': []
        }
        
        if 'package_name' in self.results['metadata']:
            package = self.results['metadata']['package_name']
            
            try:
                # Check shared preferences
                cmd = ['adb', 'shell', 'run-as', package, 'ls', '/data/data/' + package + '/shared_prefs/']
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    storage_analysis['shared_prefs'] = result.stdout.splitlines()
                
            except Exception as e:
                print(f"  [STORAGE] Analysis error: {e}")
        
        return storage_analysis
    
    def analyze_logs(self, device_id):
        """Analyze app logs for sensitive information"""
        log_analysis = {
            'sensitive_info_leaked': [],
            'errors_found': [],
            'debug_messages': []
        }
        
        try:
            # Get logcat for the app
            if 'package_name' in self.results['metadata']:
                package = self.results['metadata']['package_name']
                cmd = ['adb', 'logcat', '-d', '|', 'grep', package]
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                
                logs = result.stdout.split('\n')[:50]  # First 50 lines
                
                # Check for sensitive information
                sensitive_patterns = [
                    r'password[=:]\s*(\S+)',
                    r'token[=:]\s*(\S+)',
                    r'email[=:]\s*(\S+)',
                ]
                
                for log in logs:
                    for pattern in sensitive_patterns:
                        if re.search(pattern, log, re.IGNORECASE):
                            log_analysis['sensitive_info_leaked'].append(log[:100])
        
        except Exception as e:
            print(f"  [LOGS] Analysis error: {e}")
        
        return log_analysis
    
    def generate_vulnerability_report(self):
        """Generate comprehensive vulnerability report"""
        vulnerabilities = []
        
        # Analyze static results for vulnerabilities
        static = self.results['static_analysis']
        
        # Manifest vulnerabilities
        for issue in static.get('manifest_analysis', []):
            if 'debuggable' in issue.lower():
                vulnerabilities.append({
                    'type': 'Debugging Enabled',
                    'severity': 'High',
                    'description': issue,
                    'location': 'AndroidManifest.xml'
                })
        
        # Permission vulnerabilities
        perms = static.get('permission_analysis', {})
        if perms.get('dangerous_permissions'):
            vulnerabilities.append({
                'type': 'Excessive Permissions',
                'severity': 'Medium',
                'description': f"Dangerous permissions: {', '.join(perms['dangerous_permissions'])}",
                'location': 'AndroidManifest.xml'
            })
        
        # Code vulnerabilities
        for issue in static.get('code_analysis', []):
            if 'crypto' in issue.lower():
                vulnerabilities.append({
                    'type': 'Weak Cryptography',
                    'severity': 'High',
                    'description': issue,
                    'location': 'Code'
                })
        
        # Hardcoded secrets
        secrets = static.get('hardcoded_secrets', [])
        if secrets:
            vulnerabilities.append({
                'type': 'Hardcoded Secrets',
                'severity': 'Critical',
                'description': f"Found {len(secrets)} potential hardcoded secrets",
                'location': 'Various files'
            })
        
        self.results['vulnerabilities'] = vulnerabilities
        
        # Calculate security score (0-100, higher is better)
        base_score = 100
        for vuln in vulnerabilities:
            if vuln['severity'] == 'Critical':
                base_score -= 20
            elif vuln['severity'] == 'High':
                base_score -= 15
            elif vuln['severity'] == 'Medium':
                base_score -= 10
            elif vuln['severity'] == 'Low':
                base_score -= 5
        
        self.results['security_score'] = max(0, base_score)
        
        return vulnerabilities
    
    def generate_report(self, output_file=None):
        """Generate comprehensive security report"""
        if output_file is None:
            output_file = f"mobile_app_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        # Ensure we have all analysis results
        if not self.results['vulnerabilities']:
            self.generate_vulnerability_report()
        
        # Add metadata
        self.results['metadata']['scan_timestamp'] = datetime.now().isoformat()
        self.results['metadata']['app_type'] = self.app_type
        self.results['metadata']['app_size'] = os.path.getsize(self.app_path)
        
        # Save report
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"[REPORT] Security report saved to {output_file}")
        
        # Print summary
        self.print_summary()
        
        return output_file
    
    def print_summary(self):
        """Print scan summary to console"""
        print("\n" + "="*60)
        print("MOBILE APP SECURITY SCAN SUMMARY")
        print("="*60)
        
        print(f"App: {os.path.basename(self.app_path)}")
        print(f"Type: {self.app_type}")
        print(f"Security Score: {self.results['security_score']}/100")
        
        vuln_count = len(self.results['vulnerabilities'])
        print(f"Vulnerabilities Found: {vuln_count}")
        
        if vuln_count > 0:
            print("\nVULNERABILITIES:")
            for vuln in self.results['vulnerabilities']:
                print(f"  [{vuln['severity']}] {vuln['type']}")
                print(f"      {vuln['description']}")
        
        print("="*60)
    
    def cleanup(self):
        """Clean up temporary files"""
        import shutil
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
            print(f"[CLEANUP] Removed temporary directory: {self.temp_dir}")

def main():
    parser = argparse.ArgumentParser(description='Mobile App Vulnerability Scanner')
    parser.add_argument('app_path', help='Path to APK or IPA file')
    parser.add_argument('--output', '-o', help='Output report file')
    parser.add_argument('--dynamic', action='store_true', help='Enable dynamic analysis')
    parser.add_argument('--device', help='Android device ID for dynamic analysis')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.app_path):
        print(f"Error: App file {args.app_path} not found")
        return
    
    scanner = MobileAppScanner(args.app_path)
    
    try:
        # Detect app type
        app_type = scanner.detect_app_type()
        print(f"Detected app type: {app_type}")
        
        # Extract app
        scanner.extract_app()
        
        # Perform static analysis
        if app_type == 'android':
            static_results = scanner.static_analysis_android()
        
        # Perform dynamic analysis if requested
        if args.dynamic and app_type == 'android':
            dynamic_results = scanner.dynamic_analysis_android(args.device)
            scanner.results['dynamic_analysis'] = dynamic_results
        
        # Generate report
        report_file = scanner.generate_report(args.output)
        
    except Exception as e:
        print(f"Scan failed: {e}")
    finally:
        scanner.cleanup()

if __name__ == "__main__":
    main()
