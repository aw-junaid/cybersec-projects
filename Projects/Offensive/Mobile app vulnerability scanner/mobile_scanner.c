#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <zip.h>

#define MAX_PATH 1024
#define MAX_LINE 4096
#define MAX_VULNERABILITIES 100

typedef struct {
    char type[50];
    char severity[20];
    char description[200];
    char location[100];
} Vulnerability;

typedef struct {
    Vulnerability vulnerabilities[MAX_VULNERABILITIES];
    int count;
    int security_score;
    char app_name[MAX_PATH];
} ScanResults;

// Basic file analysis functions
int file_exists(const char *path) {
    struct stat st;
    return stat(path, &st) == 0;
}

void analyze_manifest(const char *apk_path, ScanResults *results) {
    printf("[STATIC] Analyzing AndroidManifest.xml...\n");
    
    // In a real implementation, this would extract and parse the manifest
    // This is a simplified version
    
    struct zip *apk = zip_open(apk_path, 0, NULL);
    if (apk) {
        // Look for AndroidManifest.xml
        int num_entries = zip_get_num_entries(apk, 0);
        for (int i = 0; i < num_entries; i++) {
            const char *name = zip_get_name(apk, i, 0);
            if (name && strstr(name, "AndroidManifest.xml")) {
                printf("  Found AndroidManifest.xml\n");
                
                // Add sample vulnerability
                if (results->count < MAX_VULNERABILITIES) {
                    Vulnerability *vuln = &results->vulnerabilities[results->count++];
                    strcpy(vuln->type, "Debug Flag Enabled");
                    strcpy(vuln->severity, "Medium");
                    strcpy(vuln->description, "App may be debuggable in production");
                    strcpy(vuln->location, "AndroidManifest.xml");
                }
                break;
            }
        }
        zip_close(apk);
    }
}

void search_hardcoded_secrets(const char *apk_path, ScanResults *results) {
    printf("[STATIC] Searching for hardcoded secrets...\n");
    
    // This would extract and search through app resources
    // Simplified implementation
    
    struct zip *apk = zip_open(apk_path, 0, NULL);
    if (apk) {
        int num_entries = zip_get_num_entries(apk, 0);
        int xml_files_found = 0;
        
        for (int i = 0; i < num_entries; i++) {
            const char *name = zip_get_name(apk, i, 0);
            if (name && (strstr(name, ".xml") || strstr(name, ".json"))) {
                xml_files_found++;
            }
        }
        
        printf("  Found %d potential resource files\n", xml_files_found);
        
        // Add sample finding
        if (results->count < MAX_VULNERABILITIES) {
            Vulnerability *vuln = &results->vulnerabilities[results->count++];
            strcpy(vuln->type, "Potential Hardcoded Secrets");
            strcpy(vuln->severity, "High");
            strcpy(vuln->description, "App contains configuration files that may contain secrets");
            strcpy(vuln->location, "Resource files");
        }
        
        zip_close(apk);
    }
}

void analyze_permissions(const char *apk_path, ScanResults *results) {
    printf("[STATIC] Analyzing permissions...\n");
    
    // Sample dangerous permissions check
    const char *dangerous_perms[] = {
        "ACCESS_FINE_LOCATION",
        "READ_EXTERNAL_STORAGE", 
        "CAMERA",
        "RECORD_AUDIO",
        NULL
    };
    
    printf("  Checking for dangerous permissions...\n");
    
    // Add sample finding
    if (results->count < MAX_VULNERABILITIES) {
        Vulnerability *vuln = &results->vulnerabilities[results->count++];
        strcpy(vuln->type, "Location Permission Found");
        strcpy(vuln->severity, "Medium");
        strcpy(vuln->description, "App requests location access - potential privacy concern");
        strcpy(vuln->location, "AndroidManifest.xml");
    }
}

void calculate_security_score(ScanResults *results) {
    int score = 100;
    
    for (int i = 0; i < results->count; i++) {
        if (strcmp(results->vulnerabilities[i].severity, "Critical") == 0) {
            score -= 20;
        } else if (strcmp(results->vulnerabilities[i].severity, "High") == 0) {
            score -= 15;
        } else if (strcmp(results->vulnerabilities[i].severity, "Medium") == 0) {
            score -= 10;
        } else if (strcmp(results->vulnerabilities[i].severity, "Low") == 0) {
            score -= 5;
        }
    }
    
    results->security_score = score > 0 ? score : 0;
}

void generate_report(ScanResults *results, const char *output_file) {
    printf("\nGenerating security report...\n");
    
    FILE *report = fopen(output_file, "w");
    if (!report) {
        printf("Error: Could not create report file\n");
        return;
    }
    
    fprintf(report, "MOBILE APP SECURITY SCAN REPORT\n");
    fprintf(report, "================================\n\n");
    fprintf(report, "App: %s\n", results->app_name);
    fprintf(report, "Security Score: %d/100\n\n", results->security_score);
    fprintf(report, "Vulnerabilities Found: %d\n\n", results->count);
    
    for (int i = 0; i < results->count; i++) {
        fprintf(report, "%d. [%s] %s\n", i + 1, 
                results->vulnerabilities[i].severity,
                results->vulnerabilities[i].type);
        fprintf(report, "   Description: %s\n", 
                results->vulnerabilities[i].description);
        fprintf(report, "   Location: %s\n\n", 
                results->vulnerabilities[i].location);
    }
    
    fclose(report);
    printf("Report saved to: %s\n", output_file);
}

void print_summary(ScanResults *results) {
    printf("\nSCAN SUMMARY\n");
    printf("============\n");
    printf("App: %s\n", results->app_name);
    printf("Security Score: %d/100\n", results->security_score);
    printf("Vulnerabilities Found: %d\n", results->count);
    
    if (results->count > 0) {
        printf("\nVULNERABILITIES:\n");
        for (int i = 0; i < results->count; i++) {
            printf("  [%s] %s\n", results->vulnerabilities[i].severity,
                   results->vulnerabilities[i].type);
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <apk_file> [output_report]\n", argv[0]);
        printf("Example: %s app.apk security_report.txt\n");
        return 1;
    }
    
    const char *apk_path = argv[1];
    const char *output_file = (argc > 2) ? argv[2] : "security_report.txt";
    
    if (!file_exists(apk_path)) {
        printf("Error: APK file %s not found\n", apk_path);
        return 1;
    }
    
    printf("Mobile App Vulnerability Scanner - C Implementation\n");
    printf("Scanning: %s\n", apk_path);
    
    ScanResults results;
    results.count = 0;
    results.security_score = 0;
    strncpy(results.app_name, apk_path, MAX_PATH - 1);
    
    // Perform various analyses
    analyze_manifest(apk_path, &results);
    analyze_permissions(apk_path, &results);
    search_hardcoded_secrets(apk_path, &results);
    
    // Calculate final score
    calculate_security_score(&results);
    
    // Generate outputs
    generate_report(&results, output_file);
    print_summary(&results);
    
    return 0;
}
