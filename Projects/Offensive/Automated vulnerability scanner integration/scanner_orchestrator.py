#!/usr/bin/env python3
"""
Automated Vulnerability Scanner Integration Platform
Purpose: Orchestrate and correlate results from multiple security scanners
Use: Comprehensive security assessment, continuous monitoring, enterprise scanning
"""

import asyncio
import aiohttp
import subprocess
import json
import yaml
import pandas as pd
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import sqlite3
import hashlib
import threading
from concurrent.futures import ThreadPoolExecutor
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ScannerType(Enum):
    WEB = "web"
    NETWORK = "network"
    STATIC = "static_analysis"
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    CLOUD = "cloud"

@dataclass
class ScanResult:
    scanner_name: str
    target: str
    timestamp: datetime
    vulnerabilities: List[Dict]
    raw_output: str
    scan_type: ScannerType
    confidence: float

class ScannerOrchestrator:
    def __init__(self, config_file="scanner_config.yaml"):
        self.config = self.load_config(config_file)
        self.scanners = {}
        self.results = []
        self.correlation_engine = VulnerabilityCorrelator()
        self.report_generator = ReportGenerator()
        self.setup_database()
        
    def load_config(self, config_file: str) -> Dict:
        """Load scanner configuration from YAML file"""
        try:
            with open(config_file, 'r') as f:
                config = yaml.safe_load(f)
            logger.info(f"Loaded configuration from {config_file}")
            return config
        except FileNotFoundError:
            logger.warning(f"Config file {config_file} not found, using defaults")
            return self.get_default_config()
    
    def get_default_config(self) -> Dict:
        """Return default scanner configuration"""
        return {
            'scanners': {
                'nmap': {
                    'enabled': True,
                    'command': 'nmap -sV -sC -O {target}',
                    'type': 'network',
                    'timeout': 300
                },
                'nikto': {
                    'enabled': True,
                    'command': 'nikto -h {target}',
                    'type': 'web',
                    'timeout': 600
                },
                'zap': {
                    'enabled': True,
                    'command': 'zap-baseline.py -t {target}',
                    'type': 'web',
                    'timeout': 900
                },
                'snyk': {
                    'enabled': True,
                    'command': 'snyk test --json',
                    'type': 'dependency',
                    'timeout': 300
                }
            },
            'scan_settings': {
                'max_concurrent_scans': 3,
                'result_retention_days': 30,
                'output_directory': './scan_results'
            }
        }
    
    def setup_database(self):
        """Setup SQLite database for storing scan results"""
        self.db_path = Path('scanner_results.db')
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scan_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scanner_name TEXT,
                target TEXT,
                timestamp DATETIME,
                scan_type TEXT,
                vulnerability_count INTEGER,
                raw_output TEXT,
                confidence_score REAL
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER,
                title TEXT,
                description TEXT,
                severity TEXT,
                cvss_score REAL,
                cwe_id TEXT,
                location TEXT,
                evidence TEXT,
                FOREIGN KEY (scan_id) REFERENCES scan_results (id)
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS correlation_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target TEXT,
                timestamp DATETIME,
                overall_risk_score REAL,
                critical_count INTEGER,
                high_count INTEGER,
                medium_count INTEGER,
                low_count INTEGER,
                attack_paths TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
        logger.info("Database setup completed")
    
    async def run_scan(self, target: str, scanner_config: Dict) -> Optional[ScanResult]:
        """Run a single scanner against target"""
        try:
            scanner_name = scanner_config.get('name', 'unknown')
            command = scanner_config['command'].format(target=target)
            timeout = scanner_config.get('timeout', 300)
            
            logger.info(f"Starting {scanner_name} scan for {target}")
            
            # Execute scanner command
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
            except asyncio.TimeoutError:
                logger.warning(f"{scanner_name} scan timed out for {target}")
                process.kill()
                return None
            
            if process.returncode != 0:
                logger.error(f"{scanner_name} failed with return code {process.returncode}")
                logger.error(f"Stderr: {stderr.decode()}")
                return None
            
            raw_output = stdout.decode()
            vulnerabilities = self.parse_scanner_output(scanner_name, raw_output, target)
            
            result = ScanResult(
                scanner_name=scanner_name,
                target=target,
                timestamp=datetime.now(),
                vulnerabilities=vulnerabilities,
                raw_output=raw_output,
                scan_type=ScannerType(scanner_config['type']),
                confidence=self.calculate_confidence(scanner_name, vulnerabilities)
            )
            
            logger.info(f"{scanner_name} completed: {len(vulnerabilities)} vulnerabilities found")
            return result
            
        except Exception as e:
            logger.error(f"Error running {scanner_config.get('name', 'unknown')}: {e}")
            return None
    
    def parse_scanner_output(self, scanner_name: str, output: str, target: str) -> List[Dict]:
        """Parse scanner-specific output into standardized vulnerability format"""
        vulnerabilities = []
        
        if scanner_name == 'nmap':
            vulnerabilities = self.parse_nmap_output(output, target)
        elif scanner_name == 'nikto':
            vulnerabilities = self.parse_nikto_output(output, target)
        elif scanner_name == 'zap':
            vulnerabilities = self.parse_zap_output(output, target)
        elif scanner_name == 'snyk':
            vulnerabilities = self.parse_snyk_output(output, target)
        else:
            # Generic parser for unknown scanners
            vulnerabilities = self.parse_generic_output(output, target)
        
        return vulnerabilities
    
    def parse_nmap_output(self, output: str, target: str) -> List[Dict]:
        """Parse Nmap scan results"""
        vulnerabilities = []
        
        # Parse open ports and services
        port_patterns = [
            r'(\d+)/tcp\s+open\s+(\w+)\s+(.*)',
            r'(\d+)/udp\s+open\s+(\w+)\s+(.*)'
        ]
        
        for line in output.split('\n'):
            for pattern in port_patterns:
                match = re.search(pattern, line)
                if match:
                    port, service, version = match.groups()
                    vuln = {
                        'title': f'Open Port {port}/{service.upper()}',
                        'description': f'Port {port} is open running {service} {version}',
                        'severity': 'low',
                        'cvss_score': 3.0,
                        'cwe_id': 'CWE-200',
                        'location': f'{target}:{port}',
                        'evidence': line.strip()
                    }
                    vulnerabilities.append(vuln)
        
        # Parse specific vulnerabilities from Nmap scripts
        if "VULNERABLE:" in output:
            vuln_sections = output.split("VULNERABLE:")[1:]
            for section in vuln_sections:
                lines = section.split('\n')
                if lines:
                    title = lines[0].strip()
                    vuln = {
                        'title': f'Nmap Detection: {title}',
                        'description': f'Vulnerability detected by Nmap script',
                        'severity': 'medium',
                        'cvss_score': 5.0,
                        'cwe_id': 'CWE-unknown',
                        'location': target,
                        'evidence': '\n'.join(lines[:5])
                    }
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def parse_nikto_output(self, output: str, target: str) -> List[Dict]:
        """Parse Nikto web vulnerability scanner results"""
        vulnerabilities = []
        
        for line in output.split('\n'):
            if '+ ' in line and any(keyword in line for keyword in ['OSVDB', 'may be vulnerable', 'error']):
                vuln = {
                    'title': f'Nikto Finding: {line.strip()}',
                    'description': f'Web vulnerability detected by Nikto',
                    'severity': 'medium',
                    'cvss_score': 5.5,
                    'cwe_id': 'CWE-200',
                    'location': target,
                    'evidence': line.strip()
                }
                
                # Adjust severity based on content
                if 'OSVDB' in line or 'vulnerable' in line.lower():
                    vuln['severity'] = 'high'
                    vuln['cvss_score'] = 7.5
                
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def parse_zap_output(self, output: str, target: str) -> List[Dict]:
        """Parse OWASP ZAP results (JSON format assumed)"""
        vulnerabilities = []
        
        try:
            data = json.loads(output)
            
            # Parse ZAP JSON structure
            for site in data.get('site', []):
                for alert in site.get('alerts', []):
                    vuln = {
                        'title': alert.get('name', 'Unknown'),
                        'description': alert.get('description', ''),
                        'severity': alert.get('risk', 'medium').lower(),
                        'cvss_score': self.severity_to_cvss(alert.get('risk', 'Medium')),
                        'cwe_id': alert.get('cweid', 'CWE-unknown'),
                        'location': f"{target}{alert.get('uri', '')}",
                        'evidence': alert.get('evidence', '')
                    }
                    vulnerabilities.append(vuln)
                    
        except json.JSONDecodeError:
            # Fallback to text parsing
            logger.warning("ZAP output not in JSON format, using text parsing")
            for line in output.split('\n'):
                if 'Risk:' in line and 'Confidence:' in line:
                    parts = line.split('Risk:')
                    if len(parts) > 1:
                        risk_part = parts[1].split('Confidence:')[0]
                        vuln = {
                            'title': f'ZAP Finding: {line[:100]}',
                            'description': 'Web vulnerability detected by OWASP ZAP',
                            'severity': risk_part.strip().lower(),
                            'cvss_score': self.severity_to_cvss(risk_part.strip()),
                            'cwe_id': 'CWE-unknown',
                            'location': target,
                            'evidence': line.strip()
                        }
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def parse_snyk_output(self, output: str, target: str) -> List[Dict]:
        """Parse Snyk dependency vulnerability results"""
        vulnerabilities = []
        
        try:
            data = json.loads(output)
            
            for vulnerability in data.get('vulnerabilities', []):
                vuln = {
                    'title': f"{vulnerability.get('package', 'Unknown')} - {vulnerability.get('title', 'Vulnerability')}",
                    'description': vulnerability.get('description', ''),
                    'severity': vulnerability.get('severity', 'medium').lower(),
                    'cvss_score': vulnerability.get('cvssScore', 5.0),
                    'cwe_id': f"CWE-{vulnerability.get('identifiers', {}).get('CWE', ['unknown'])[0]}",
                    'location': f"{target} - {vulnerability.get('package', 'unknown')}",
                    'evidence': f"Version: {vulnerability.get('version', 'unknown')}"
                }
                vulnerabilities.append(vuln)
                
        except json.JSONDecodeError:
            logger.warning("Snyk output not in JSON format")
        
        return vulnerabilities
    
    def parse_generic_output(self, output: str, target: str) -> List[Dict]:
        """Generic parser for unknown scanner outputs"""
        vulnerabilities = []
        
        # Look for common vulnerability patterns
        patterns = {
            'high': [r'critical', r'high', r'vulnerability', r'CVE-\d+-\d+', r'exploit'],
            'medium': [r'warning', r'medium', r'issue', r'finding'],
            'low': [r'info', r'low', r'note']
        }
        
        for severity, severity_patterns in patterns.items():
            for pattern in severity_patterns:
                matches = re.finditer(pattern, output, re.IGNORECASE)
                for match in matches:
                    # Extract context around the match
                    start = max(0, match.start() - 50)
                    end = min(len(output), match.end() + 50)
                    context = output[start:end]
                    
                    vuln = {
                        'title': f'Generic Finding: {pattern}',
                        'description': f'Vulnerability pattern detected: {pattern}',
                        'severity': severity,
                        'cvss_score': self.severity_to_cvss(severity),
                        'cwe_id': 'CWE-unknown',
                        'location': target,
                        'evidence': context
                    }
                    vulnerabilities.append(vuln)
                    break  # Avoid duplicate matches for same line
        
        return vulnerabilities
    
    def severity_to_cvss(self, severity: str) -> float:
        """Convert textual severity to CVSS score"""
        severity_map = {
            'critical': 9.0,
            'high': 7.0,
            'medium': 5.0,
            'low': 3.0,
            'info': 0.0
        }
        return severity_map.get(severity.lower(), 5.0)
    
    def calculate_confidence(self, scanner_name: str, vulnerabilities: List[Dict]) -> float:
        """Calculate confidence score for scanner results"""
        base_confidence = {
            'nmap': 0.9,
            'nikto': 0.7,
            'zap': 0.8,
            'snyk': 0.85
        }.get(scanner_name, 0.5)
        
        # Adjust confidence based on number of findings
        if len(vulnerabilities) == 0:
            return base_confidence * 0.8  # Lower confidence for no findings
        elif len(vulnerabilities) > 50:
            return base_confidence * 0.9  # Slightly lower for too many findings
        
        return base_confidence
    
    async def orchestrate_scan(self, target: str, scan_types: List[ScannerType] = None) -> Dict:
        """Orchestrate multiple scanners against a target"""
        if scan_types is None:
            scan_types = [ScannerType.WEB, ScannerType.NETWORK]
        
        logger.info(f"Starting orchestrated scan for {target}")
        
        # Filter enabled scanners by type
        enabled_scanners = []
        for scanner_name, scanner_config in self.config['scanners'].items():
            if (scanner_config.get('enabled', False) and 
                ScannerType(scanner_config['type']) in scan_types):
                scanner_config['name'] = scanner_name
                enabled_scanners.append(scanner_config)
        
        # Run scans concurrently
        max_concurrent = self.config['scan_settings'].get('max_concurrent_scans', 3)
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def run_with_semaphore(scanner_config):
            async with semaphore:
                return await self.run_scan(target, scanner_config)
        
        tasks = [run_with_semaphore(scanner) for scanner in enabled_scanners]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filter out None results and exceptions
        valid_results = [r for r in results if r is not None and not isinstance(r, Exception)]
        
        # Store results
        for result in valid_results:
            self.store_scan_result(result)
            self.results.append(result)
        
        # Correlate results
        correlation_result = self.correlation_engine.correlate_results(valid_results, target)
        
        logger.info(f"Orchestrated scan completed for {target}")
        logger.info(f"Scanners run: {len(valid_results)}, Vulnerabilities found: {sum(len(r.vulnerabilities) for r in valid_results)}")
        
        return {
            'target': target,
            'scan_results': valid_results,
            'correlation': correlation_result,
            'timestamp': datetime.now()
        }
    
    def store_scan_result(self, result: ScanResult):
        """Store scan result in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO scan_results 
            (scanner_name, target, timestamp, scan_type, vulnerability_count, raw_output, confidence_score)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            result.scanner_name,
            result.target,
            result.timestamp.isoformat(),
            result.scan_type.value,
            len(result.vulnerabilities),
            result.raw_output,
            result.confidence
        ))
        
        scan_id = cursor.lastrowid
        
        for vuln in result.vulnerabilities:
            cursor.execute('''
                INSERT INTO vulnerabilities 
                (scan_id, title, description, severity, cvss_score, cwe_id, location, evidence)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                scan_id,
                vuln['title'],
                vuln['description'],
                vuln['severity'],
                vuln['cvss_score'],
                vuln['cwe_id'],
                vuln['location'],
                vuln['evidence']
            ))
        
        conn.commit()
        conn.close()
    
    def get_scan_history(self, target: str = None, days: int = 30) -> List[Dict]:
        """Retrieve scan history from database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = '''
            SELECT sr.*, COUNT(v.id) as vuln_count
            FROM scan_results sr
            LEFT JOIN vulnerabilities v ON sr.id = v.scan_id
            WHERE sr.timestamp >= datetime('now', ?)
        '''
        params = [f'-{days} days']
        
        if target:
            query += ' AND sr.target = ?'
            params.append(target)
        
        query += ' GROUP BY sr.id ORDER BY sr.timestamp DESC'
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        
        columns = [desc[0] for desc in cursor.description]
        results = [dict(zip(columns, row)) for row in rows]
        
        conn.close()
        return results

class VulnerabilityCorrelator:
    """Correlate vulnerabilities from multiple scanners"""
    
    def __init__(self):
        self.cve_pattern = re.compile(r'CVE-\d{4}-\d+', re.IGNORECASE)
        self.cwe_pattern = re.compile(r'CWE-(\d+)', re.IGNORECASE)
    
    def correlate_results(self, scan_results: List[ScanResult], target: str) -> Dict:
        """Correlate vulnerabilities from multiple scanners"""
        all_vulnerabilities = []
        
        for result in scan_results:
            for vuln in result.vulnerabilities:
                vuln['scanner'] = result.scanner_name
                vuln['scanner_confidence'] = result.confidence
                all_vulnerabilities.append(vuln)
        
        # Group by location and type
        grouped_vulns = self.group_vulnerabilities(all_vulnerabilities)
        
        # Calculate risk scores
        risk_assessment = self.assess_risk(grouped_vulns)
        
        # Identify attack paths
        attack_paths = self.identify_attack_paths(grouped_vulns, target)
        
        return {
            'risk_assessment': risk_assessment,
            'vulnerability_groups': grouped_vulns,
            'attack_paths': attack_paths,
            'total_unique_vulnerabilities': len(all_vulnerabilities),
            'correlation_timestamp': datetime.now().isoformat()
        }
    
    def group_vulnerabilities(self, vulnerabilities: List[Dict]) -> Dict:
        """Group vulnerabilities by common characteristics"""
        groups = {}
        
        for vuln in vulnerabilities:
            # Create grouping key based on location and title
            location = vuln.get('location', 'unknown')
            title_key = vuln['title'].lower()
            
            key = f"{location}|{title_key}"
            
            if key not in groups:
                groups[key] = {
                    'location': location,
                    'title': vuln['title'],
                    'vulnerabilities': [],
                    'scanner_count': set(),
                    'max_severity': 'low',
                    'max_cvss': 0.0
                }
            
            groups[key]['vulnerabilities'].append(vuln)
            groups[key]['scanner_count'].add(vuln['scanner'])
            
            # Update max severity
            current_severity = groups[key]['max_severity']
            new_severity = vuln['severity']
            if self.severity_value(new_severity) > self.severity_value(current_severity):
                groups[key]['max_severity'] = new_severity
                groups[key]['max_cvss'] = max(groups[key]['max_cvss'], vuln['cvss_score'])
        
        return groups
    
    def severity_value(self, severity: str) -> int:
        """Convert severity to numerical value for comparison"""
        severity_map = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1, 'info': 0}
        return severity_map.get(severity.lower(), 0)
    
    def assess_risk(self, vulnerability_groups: Dict) -> Dict:
        """Assess overall risk based on correlated vulnerabilities"""
        risk_score = 0
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        
        for group in vulnerability_groups.values():
            severity = group['max_severity']
            severity_counts[severity] += 1
            
            # Weight by scanner confirmation
            scanner_weight = len(group['scanner_count'])
            severity_weight = self.severity_value(severity)
            
            risk_score += severity_weight * scanner_weight * 2
        
        # Normalize risk score (0-100)
        risk_score = min(100, risk_score)
        
        risk_level = 'Low'
        if risk_score >= 80:
            risk_level = 'Critical'
        elif risk_score >= 60:
            risk_level = 'High'
        elif risk_score >= 40:
            risk_level = 'Medium'
        
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'severity_distribution': severity_counts,
            'total_groups': len(vulnerability_groups)
        }
    
    def identify_attack_paths(self, vulnerability_groups: Dict, target: str) -> List[Dict]:
        """Identify potential attack paths through correlated vulnerabilities"""
        attack_paths = []
        
        # Simple heuristic-based attack path identification
        critical_vulns = [v for v in vulnerability_groups.values() 
                         if v['max_severity'] in ['critical', 'high']]
        
        medium_vulns = [v for v in vulnerability_groups.values() 
                       if v['max_severity'] == 'medium']
        
        # Create attack paths combining critical and medium vulnerabilities
        for crit_vuln in critical_vulns[:3]:  # Limit to top 3 critical
            path = {
                'entry_point': crit_vuln['location'],
                'vulnerabilities': [crit_vuln],
                'complexity': 'low',
                'potential_impact': 'high'
            }
            
            # Add related medium vulnerabilities
            for med_vuln in medium_vulns[:2]:
                if self.are_related(crit_vuln, med_vuln):
                    path['vulnerabilities'].append(med_vuln)
                    path['complexity'] = 'medium'
            
            attack_paths.append(path)
        
        return attack_paths
    
    def are_related(self, vuln1: Dict, vuln2: Dict) -> bool:
        """Check if two vulnerabilities are related"""
        # Same location
        if vuln1['location'] == vuln2['location']:
            return True
        
        # Similar titles
        title1 = vuln1['title'].lower()
        title2 = vuln2['title'].lower()
        
        common_terms = ['sql', 'xss', 'injection', 'buffer', 'overflow', 'auth']
        for term in common_terms:
            if term in title1 and term in title2:
                return True
        
        return False

class ReportGenerator:
    """Generate comprehensive security reports"""
    
    def generate_html_report(self, correlation_result: Dict, output_path: str = None):
        """Generate HTML security report"""
        if output_path is None:
            output_path = f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        risk = correlation_result['risk_assessment']
        vuln_groups = correlation_result['vulnerability_groups']
        attack_paths = correlation_result['attack_paths']
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Security Assessment Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .risk-critical {{ color: #ff0000; font-weight: bold; }}
                .risk-high {{ color: #ff6600; font-weight: bold; }}
                .risk-medium {{ color: #ffcc00; font-weight: bold; }}
                .risk-low {{ color: #00cc00; }}
                .vulnerability {{ border: 1px solid #ddd; padding: 10px; margin: 10px 0; }}
                .attack-path {{ background: #f9f9f9; padding: 15px; margin: 10px 0; border-left: 4px solid #007acc; }}
            </style>
        </head>
        <body>
            <h1>Security Assessment Report</h1>
            <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            
            <h2>Risk Summary</h2>
            <p>Overall Risk: <span class="risk-{risk['risk_level'].lower()}">{risk['risk_level']}</span></p>
            <p>Risk Score: {risk['risk_score']}/100</p>
            
            <h2>Vulnerability Summary</h2>
            <p>Critical: {risk['severity_distribution']['critical']}</p>
            <p>High: {risk['severity_distribution']['high']}</p>
            <p>Medium: {risk['severity_distribution']['medium']}</p>
            <p>Low: {risk['severity_distribution']['low']}</p>
            
            <h2>Attack Paths</h2>
            {self.generate_attack_paths_html(attack_paths)}
            
            <h2>Detailed Vulnerabilities</h2>
            {self.generate_vulnerabilities_html(vuln_groups)}
        </body>
        </html>
        """
        
        with open(output_path, 'w') as f:
            f.write(html_content)
        
        logger.info(f"HTML report generated: {output_path}")
        return output_path
    
    def generate_attack_paths_html(self, attack_paths: List[Dict]) -> str:
        """Generate HTML for attack paths section"""
        if not attack_paths:
            return "<p>No significant attack paths identified.</p>"
        
        html = ""
        for i, path in enumerate(attack_paths, 1):
            html += f"""
            <div class="attack-path">
                <h3>Attack Path {i}</h3>
                <p><strong>Entry Point:</strong> {path['entry_point']}</p>
                <p><strong>Complexity:</strong> {path['complexity']}</p>
                <p><strong>Potential Impact:</strong> {path['potential_impact']}</p>
                <h4>Vulnerabilities in this path:</h4>
                <ul>
            """
            
            for vuln in path['vulnerabilities']:
                html += f"<li>{vuln['title']} ({vuln['max_severity']})</li>"
            
            html += "</ul></div>"
        
        return html
    
    def generate_vulnerabilities_html(self, vulnerability_groups: Dict) -> str:
        """Generate HTML for vulnerabilities section"""
        html = ""
        
        for group_key, group in vulnerability_groups.items():
            html += f"""
            <div class="vulnerability">
                <h3>{group['title']}</h3>
                <p><strong>Location:</strong> {group['location']}</p>
                <p><strong>Severity:</strong> <span class="risk-{group['max_severity']}">{group['max_severity']}</span></p>
                <p><strong>CVSS Score:</strong> {group['max_cvss']}</p>
                <p><strong>Confirmed by:</strong> {', '.join(group['scanner_count'])}</p>
            </div>
            """
        
        return html
    
    def generate_csv_report(self, correlation_result: Dict, output_path: str = None):
        """Generate CSV report"""
        if output_path is None:
            output_path = f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        vuln_groups = correlation_result['vulnerability_groups']
        
        data = []
        for group in vuln_groups.values():
            data.append({
                'Title': group['title'],
                'Location': group['location'],
                'Severity': group['max_severity'],
                'CVSS': group['max_cvss'],
                'Scanners': ', '.join(group['scanner_count']),
                'Vulnerability_Count': len(group['vulnerabilities'])
            })
        
        df = pd.DataFrame(data)
        df.to_csv(output_path, index=False)
        
        logger.info(f"CSV report generated: {output_path}")
        return output_path

async def main():
    """Main execution function"""
    parser = argparse.ArgumentParser(description='Vulnerability Scanner Orchestrator')
    parser.add_argument('target', help='Target to scan (URL, IP, or file path)')
    parser.add_argument('--config', default='scanner_config.yaml', help='Scanner configuration file')
    parser.add_argument('--scan-types', nargs='+', choices=['web', 'network', 'static', 'dependency', 'container', 'cloud'],
                       default=['web', 'network'], help='Types of scans to perform')
    parser.add_argument('--output', help='Output report file')
    parser.add_argument('--format', choices=['html', 'csv', 'json'], default='html', help='Report format')
    
    args = parser.parse_args()
    
    # Initialize orchestrator
    orchestrator = ScannerOrchestrator(args.config)
    
    # Convert scan types to enum
    scan_types = [ScannerType(st) for st in args.scan_types]
    
    # Run orchestrated scan
    result = await orchestrator.orchestrate_scan(args.target, scan_types)
    
    # Generate report
    report_generator = ReportGenerator()
    
    if args.format == 'html':
        report_path = report_generator.generate_html_report(result['correlation'], args.output)
    elif args.format == 'csv':
        report_path = report_generator.generate_csv_report(result['correlation'], args.output)
    else:
        # JSON output
        if args.output:
            report_path = args.output
        else:
            report_path = f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_path, 'w') as f:
            json.dump(result, f, indent=2)
    
    print(f"Scan completed. Report saved to: {report_path}")
    print(f"Risk Level: {result['correlation']['risk_assessment']['risk_level']}")
    print(f"Total Vulnerabilities: {result['correlation']['total_unique_vulnerabilities']}")

if __name__ == "__main__":
    import re  # Add missing import
    asyncio.run(main())
