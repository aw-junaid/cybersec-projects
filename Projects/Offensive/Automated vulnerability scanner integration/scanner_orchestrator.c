#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>
#include <jansson.h>
#include <sqlite3.h>

#define MAX_SCANNERS 10
#define MAX_RESULT_SIZE 1048576 // 1MB
#define MAX_SCANNER_NAME 50
#define MAX_TARGET_LENGTH 256

typedef struct {
    char name[MAX_SCANNER_NAME];
    char command[512];
    char type[20];
    int enabled;
    int timeout;
} ScannerConfig;

typedef struct {
    char scanner_name[MAX_SCANNER_NAME];
    char target[MAX_TARGET_LENGTH];
    char timestamp[64];
    char raw_output[MAX_RESULT_SIZE];
    int vulnerability_count;
    double confidence_score;
} ScanResult;

typedef struct {
    ScannerConfig scanners[MAX_SCANNERS];
    int scanner_count;
    int max_concurrent_scans;
    char output_dir[256];
} OrchestratorConfig;

// Function prototypes
int load_config(const char* config_file, OrchestratorConfig* config);
int execute_scanner(const ScannerConfig* scanner, const char* target, ScanResult* result);
void* scanner_worker(void* arg);
int parse_nmap_output(const char* output, json_t* vulnerabilities);
int parse_nikto_output(const char* output, json_t* vulnerabilities);
void store_result_in_db(const ScanResult* result);
double calculate_confidence(const char* scanner_name, int vuln_count);

int main(int argc, char* argv[]) {
    if (argc < 3) {
        printf("Usage: %s <config_file> <target>\n", argv[0]);
        return 1;
    }

    OrchestratorConfig config;
    if (load_config(argv[1], &config) != 0) {
        fprintf(stderr, "Failed to load configuration\n");
        return 1;
    }

    printf("Starting vulnerability scan orchestration for target: %s\n", argv[2]);
    printf("Loaded %d scanners\n", config.scanner_count);

    // Create worker threads for each enabled scanner
    pthread_t threads[MAX_SCANNERS];
    int thread_count = 0;

    for (int i = 0; i < config.scanner_count; i++) {
        if (config.scanners[i].enabled) {
            // Prepare thread arguments
            struct {
                ScannerConfig scanner;
                char target[MAX_TARGET_LENGTH];
            } *thread_arg = malloc(sizeof(*thread_arg));
            
            thread_arg->scanner = config.scanners[i];
            strncpy(thread_arg->target, argv[2], MAX_TARGET_LENGTH - 1);
            
            if (pthread_create(&threads[thread_count], NULL, scanner_worker, thread_arg) == 0) {
                thread_count++;
            } else {
                free(thread_arg);
            }
        }
    }

    // Wait for all threads to complete
    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Scan orchestration completed. %d scanners executed.\n", thread_count);
    return 0;
}

int load_config(const char* config_file, OrchestratorConfig* config) {
    // Simplified configuration loading
    // In practice, this would parse JSON or YAML
    
    // Initialize with default scanners
    config->scanner_count = 2;
    config->max_concurrent_scans = 3;
    strcpy(config->output_dir, "./results");
    
    // Nmap scanner
    strcpy(config->scanners[0].name, "nmap");
    strcpy(config->scanners[0].command, "nmap -sV -sC %s");
    strcpy(config->scanners[0].type, "network");
    config->scanners[0].enabled = 1;
    config->scanners[0].timeout = 300;
    
    // Nikto scanner
    strcpy(config->scanners[1].name, "nikto");
    strcpy(config->scanners[1].command, "nikto -h %s");
    strcpy(config->scanners[1].type, "web");
    config->scanners[1].enabled = 1;
    config->scanners[1].timeout = 600;
    
    return 0;
}

void* scanner_worker(void* arg) {
    struct {
        ScannerConfig scanner;
        char target[MAX_TARGET_LENGTH];
    } *thread_arg = (typeof(thread_arg))arg;
    
    ScanResult result;
    strcpy(result.scanner_name, thread_arg->scanner.name);
    strcpy(result.target, thread_arg->target);
    
    // Execute scanner
    if (execute_scanner(&thread_arg->scanner, thread_arg->target, &result) == 0) {
        printf("Scanner %s completed successfully. Found %d vulnerabilities.\n", 
               result.scanner_name, result.vulnerability_count);
        
        // Store result
        store_result_in_db(&result);
    } else {
        fprintf(stderr, "Scanner %s failed\n", thread_arg->scanner.name);
    }
    
    free(thread_arg);
    return NULL;
}

int execute_scanner(const ScannerConfig* scanner, const char* target, ScanResult* result) {
    printf("Executing scanner: %s\n", scanner->name);
    
    // Build command with target
    char command[1024];
    snprintf(command, sizeof(command), scanner->command, target);
    
    // Execute command and capture output
    FILE* fp = popen(command, "r");
    if (fp == NULL) {
        return -1;
    }
    
    char buffer[4096];
    size_t total_size = 0;
    
    while (fgets(buffer, sizeof(buffer), fp) != NULL && total_size < MAX_RESULT_SIZE - 1) {
        size_t len = strlen(buffer);
        if (total_size + len < MAX_RESULT_SIZE - 1) {
            strncpy(result->raw_output + total_size, buffer, len);
            total_size += len;
        }
    }
    
    result->raw_output[total_size] = '\0';
    
    int status = pclose(fp);
    
    // Parse output based on scanner type
    json_t* vulnerabilities = json_array();
    
    if (strcmp(scanner->name, "nmap") == 0) {
        result->vulnerability_count = parse_nmap_output(result->raw_output, vulnerabilities);
    } else if (strcmp(scanner->name, "nikto") == 0) {
        result->vulnerability_count = parse_nikto_output(result->raw_output, vulnerabilities);
    }
    
    result->confidence_score = calculate_confidence(scanner->name, result->vulnerability_count);
    
    // Get current timestamp
    time_t now = time(NULL);
    strftime(result->timestamp, sizeof(result->timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
    
    json_decref(vulnerabilities);
    
    return (WIFEXITED(status) && WEXITSTATUS(status) == 0) ? 0 : -1;
}

int parse_nmap_output(const char* output, json_t* vulnerabilities) {
    int vuln_count = 0;
    const char* line = output;
    
    while (*line) {
        const char* next_line = strchr(line, '\n');
        if (next_line == NULL) {
            break;
        }
        
        size_t line_len = next_line - line;
        char line_buf[1024];
        
        if (line_len >= sizeof(line_buf)) {
            line_len = sizeof(line_buf) - 1;
        }
        
        strncpy(line_buf, line, line_len);
        line_buf[line_len] = '\0';
        
        // Look for open ports
        if (strstr(line_buf, "open") != NULL && strstr(line_buf, "tcp") != NULL) {
            json_t* vuln = json_object();
            json_object_set_new(vuln, "title", json_string("Open Port Found"));
            json_object_set_new(vuln, "severity", json_string("low"));
            json_object_set_new(vuln, "description", json_string(line_buf));
            
            json_array_append_new(vulnerabilities, vuln);
            vuln_count++;
        }
        
        line = next_line + 1;
    }
    
    return vuln_count;
}

int parse_nikto_output(const char* output, json_t* vulnerabilities) {
    int vuln_count = 0;
    const char* line = output;
    
    while (*line) {
        const char* next_line = strchr(line, '\n');
        if (next_line == NULL) {
            break;
        }
        
        size_t line_len = next_line - line;
        char line_buf[1024];
        
        if (line_len >= sizeof(line_buf)) {
            line_len = sizeof(line_buf) - 1;
        }
        
        strncpy(line_buf, line, line_len);
        line_buf[line_len] = '\0';
        
        // Look for Nikto findings
        if (strstr(line_buf, "+") != NULL) {
            json_t* vuln = json_object();
            json_object_set_new(vuln, "title", json_string("Nikto Finding"));
            json_object_set_new(vuln, "severity", json_string("medium"));
            json_object_set_new(vuln, "description", json_string(line_buf));
            
            json_array_append_new(vulnerabilities, vuln);
            vuln_count++;
        }
        
        line = next_line + 1;
    }
    
    return vuln_count;
}

double calculate_confidence(const char* scanner_name, int vuln_count) {
    if (strcmp(scanner_name, "nmap") == 0) {
        return 0.9;
    } else if (strcmp(scanner_name, "nikto") == 0) {
        return 0.7;
    }
    
    return 0.5;
}

void store_result_in_db(const ScanResult* result) {
    sqlite3* db;
    char* err_msg = NULL;
    
    if (sqlite3_open("scan_results.db", &db) != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        return;
    }
    
    const char* sql = "CREATE TABLE IF NOT EXISTS scan_results ("
                      "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                      "scanner_name TEXT,"
                      "target TEXT,"
                      "timestamp TEXT,"
                      "vulnerability_count INTEGER,"
                      "confidence_score REAL);";
    
    if (sqlite3_exec(db, sql, NULL, NULL, &err_msg) != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    
    char insert_sql[1024];
    snprintf(insert_sql, sizeof(insert_sql),
             "INSERT INTO scan_results (scanner_name, target, timestamp, vulnerability_count, confidence_score) "
             "VALUES ('%s', '%s', '%s', %d, %f);",
             result->scanner_name, result->target, result->timestamp, 
             result->vulnerability_count, result->confidence_score);
    
    if (sqlite3_exec(db, insert_sql, NULL, NULL, &err_msg) != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    
    sqlite3_close(db);
}
