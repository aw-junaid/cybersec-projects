#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_STEPS 20
#define MAX_NAME_LENGTH 50
#define MAX_DESC_LENGTH 200

typedef enum {
    STATUS_PENDING,
    STATUS_RUNNING,
    STATUS_SUCCESS,
    STATUS_FAILED,
    STATUS_SKIPPED
} ExploitStatus;

typedef struct {
    char name[MAX_NAME_LENGTH];
    char description[MAX_DESC_LENGTH];
    char target[MAX_NAME_LENGTH];
    char technique[MAX_NAME_LENGTH];
    char prerequisites[MAX_STEPS][MAX_NAME_LENGTH];
    int prereq_count;
    ExploitStatus status;
    time_t start_time;
    time_t end_time;
} ExploitStep;

typedef struct {
    char name[MAX_NAME_LENGTH];
    ExploitStep steps[MAX_STEPS];
    int step_count;
    ExploitStatus overall_status;
} ExploitChain;

void initialize_chain(ExploitChain *chain, const char *name) {
    strncpy(chain->name, name, MAX_NAME_LENGTH);
    chain->step_count = 0;
    chain->overall_status = STATUS_PENDING;
}

void add_step(ExploitChain *chain, const char *name, const char *desc, 
              const char *target, const char *technique) {
    if (chain->step_count >= MAX_STEPS) {
        printf("Cannot add more steps to chain\n");
        return;
    }
    
    ExploitStep *step = &chain->steps[chain->step_count];
    strncpy(step->name, name, MAX_NAME_LENGTH);
    strncpy(step->description, desc, MAX_DESC_LENGTH);
    strncpy(step->target, target, MAX_NAME_LENGTH);
    strncpy(step->technique, technique, MAX_NAME_LENGTH);
    step->prereq_count = 0;
    step->status = STATUS_PENDING;
    
    chain->step_count++;
}

void add_prerequisite(ExploitChain *chain, int step_index, const char *prereq_name) {
    if (step_index < 0 || step_index >= chain->step_count) {
        printf("Invalid step index\n");
        return;
    }
    
    ExploitStep *step = &chain->steps[step_index];
    if (step->prereq_count >= MAX_STEPS) {
        printf("Cannot add more prerequisites\n");
        return;
    }
    
    strncpy(step->prerequisites[step->prereq_count], prereq_name, MAX_NAME_LENGTH);
    step->prereq_count++;
}

int execute_chain(ExploitChain *chain) {
    printf("Executing chain: %s\n", chain->name);
    printf("Steps: %d\n", chain->step_count);
    
    chain->overall_status = STATUS_RUNNING;
    int success_count = 0;
    
    for (int i = 0; i < chain->step_count; i++) {
        ExploitStep *step = &chain->steps[i];
        
        printf("\nStep %d: %s\n", i + 1, step->name);
        printf("  Target: %s\n", step->target);
        printf("  Technique: %s\n", step->technique);
        
        // Check prerequisites
        int prerequisites_met = 1;
        for (int j = 0; j < step->prereq_count; j++) {
            // Find prerequisite step
            int prereq_met = 0;
            for (int k = 0; k < i; k++) {
                if (strcmp(chain->steps[k].name, step->prerequisites[j]) == 0 &&
                    chain->steps[k].status == STATUS_SUCCESS) {
                    prereq_met = 1;
                    break;
                }
            }
            
            if (!prereq_met) {
                printf("  [!] Prerequisite not met: %s\n", step->prerequisites[j]);
                prerequisites_met = 0;
                step->status = STATUS_SKIPPED;
                break;
            }
        }
        
        if (!prerequisites_met) {
            continue;
        }
        
        // Execute step
        step->status = STATUS_RUNNING;
        step->start_time = time(NULL);
        
        printf("  [*] Executing...\n");
        
        // Simulate execution (replace with actual exploit code)
        sleep(2);
        
        // Simulate success (90% chance)
        int success = rand() % 10 < 9;
        
        step->end_time = time(NULL);
        step->status = success ? STATUS_SUCCESS : STATUS_FAILED;
        
        if (success) {
            printf("  [+] Success\n");
            success_count++;
        } else {
            printf("  [-] Failed\n");
            break;
        }
    }
    
    chain->overall_status = (success_count == chain->step_count) ? STATUS_SUCCESS : STATUS_FAILED;
    return chain->overall_status == STATUS_SUCCESS;
}

void print_chain_report(ExploitChain *chain) {
    printf("\n=== CHAIN EXECUTION REPORT ===\n");
    printf("Chain: %s\n", chain->name);
    printf("Overall Status: %s\n", 
           chain->overall_status == STATUS_SUCCESS ? "SUCCESS" : 
           chain->overall_status == STATUS_FAILED ? "FAILED" : "PENDING");
    
    printf("\nStep Details:\n");
    for (int i = 0; i < chain->step_count; i++) {
        ExploitStep *step = &chain->steps[i];
        printf("  %d. %s: %s\n", i + 1, step->name, 
               step->status == STATUS_SUCCESS ? "SUCCESS" :
               step->status == STATUS_FAILED ? "FAILED" :
               step->status == STATUS_SKIPPED ? "SKIPPED" : "PENDING");
    }
}

void demonstrate_web_exploit_chain() {
    printf("\n=== WEB EXPLOIT CHAIN DEMONSTRATION ===\n");
    
    ExploitChain chain;
    initialize_chain(&chain, "Web Application Chain");
    
    add_step(&chain, "Reconnaissance", "Information gathering", "web_server", "scanning");
    add_step(&chain, "SQL Injection", "Exploit SQLi vulnerability", "web_app", "sql_injection");
    add_step(&chain, "Web Shell", "Upload web shell", "web_server", "file_upload");
    add_step(&chain, "Reverse Shell", "Establish reverse connection", "web_server", "rce");
    
    add_prerequisite(&chain, 1, "Reconnaissance");  // SQLi needs Recon
    add_prerequisite(&chain, 2, "SQL Injection");   // Web Shell needs SQLi
    add_prerequisite(&chain, 3, "Web Shell");       // Reverse Shell needs Web Shell
    
    execute_chain(&chain);
    print_chain_report(&chain);
}

void demonstrate_lateral_movement_chain() {
    printf("\n=== LATERAL MOVEMENT CHAIN DEMONSTRATION ===\n");
    
    ExploitChain chain;
    initialize_chain(&chain, "Lateral Movement Chain");
    
    add_step(&chain, "Initial Access", "Gain initial foothold", "workstation", "phishing");
    add_step(&chain, "Credential Harvest", "Dump credentials", "workstation", "mimikatz");
    add_step(&chain, "Network Scan", "Discover other hosts", "network", "nmap");
    add_step(&chain, "Lateral Move", "Move to server", "server", "psexec");
    add_step(&chain, "Domain Compromise", "Take over domain", "domain_controller", "golden_ticket");
    
    add_prerequisite(&chain, 1, "Initial Access");
    add_prerequisite(&chain, 2, "Credential Harvest");
    add_prerequisite(&chain, 3, "Network Scan");
    add_prerequisite(&chain, 4, "Lateral Move");
    
    execute_chain(&chain);
    print_chain_report(&chain);
}

int main() {
    srand(time(NULL));  // Seed for random success/failure
    
    printf("Exploit Chaining Workflow Framework\n");
    printf("===================================\n");
    printf("FOR AUTHORIZED PENETRATION TESTING ONLY\n\n");
    
    demonstrate_web_exploit_chain();
    demonstrate_lateral_movement_chain();
    
    printf("\n=== CHAIN DESIGN BEST PRACTICES ===\n");
    printf("1. Start with reconnaissance and information gathering\n");
    printf("2. Chain low-risk exploits before high-risk ones\n");
    printf("3. Include error handling and fallback options\n");
    printf("4. Test each step independently before chaining\n");
    printf("5. Document prerequisites and dependencies\n");
    printf("6. Include cleanup and persistence steps\n");
    printf("7. Plan for detection evasion throughout the chain\n");
    
    return 0;
}
