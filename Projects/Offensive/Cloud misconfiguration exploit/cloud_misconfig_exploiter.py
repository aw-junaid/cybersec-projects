#!/usr/bin/env python3
import boto3
import requests
import json
import argparse
import threading
from concurrent.futures import ThreadPoolExecutor
from botocore.exceptions import ClientError, NoCredentialsError
import azure.mgmt.storage
import azure.mgmt.compute
from azure.identity import DefaultAzureCredential
from google.cloud import storage, compute_v1
from google.auth import default
import os
import re
from dataclasses import dataclass
from typing import List, Dict, Any
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

@dataclass
class CloudMisconfig:
    service: str
    resource: str
    misconfiguration: str
    risk: str
    evidence: str
    exploitation: str = ""

class CloudMisconfigExploiter:
    def __init__(self):
        self.results = []
        self.aws_session = None
        self.azure_credential = None
        self.gcp_credentials = None
        
    def initialize_aws(self):
        """Initialize AWS session"""
        try:
            self.aws_session = boto3.Session()
            sts = self.aws_session.client('sts')
            identity = sts.get_caller_identity()
            print(f"[+] AWS Session initialized for: {identity['Arn']}")
            return True
        except NoCredentialsError:
            print("[-] No AWS credentials found")
            return False
    
    def initialize_azure(self):
        """Initialize Azure credentials"""
        try:
            self.azure_credential = DefaultAzureCredential()
            print("[+] Azure credentials initialized")
            return True
        except Exception as e:
            print(f"[-] Azure initialization failed: {e}")
            return False
    
    def initialize_gcp(self):
        """Initialize GCP credentials"""
        try:
            self.gcp_credentials, project = default()
            print(f"[+] GCP credentials initialized for project: {project}")
            return True
        except Exception as e:
            print(f"[-] GCP initialization failed: {e}")
            return False
    
    def scan_aws_s3_buckets(self):
        """Scan for misconfigured S3 buckets"""
        print("[*] Scanning AWS S3 buckets for misconfigurations...")
        
        try:
            s3 = self.aws_session.client('s3')
            s3_resource = self.aws_session.resource('s3')
            
            # List all buckets
            response = s3.list_buckets()
            
            for bucket in response['Buckets']:
                bucket_name = bucket['Name']
                
                try:
                    # Check bucket ACL
                    acl = s3.get_bucket_acl(Bucket=bucket_name)
                    for grant in acl['Grants']:
                        if 'URI' in grant['Grantee'] and 'AllUsers' in grant['Grantee']['URI']:
                            self.results.append(CloudMisconfig(
                                service="S3",
                                resource=bucket_name,
                                misconfiguration="Public Read Access",
                                risk="HIGH",
                                evidence=f"AllUsers grant with permission: {grant['Permission']}",
                                exploitation=f"aws s3 ls s3://{bucket_name}/ --no-sign-request"
                            ))
                    
                    # Check bucket policy
                    try:
                        policy = s3.get_bucket_policy(Bucket=bucket_name)
                        policy_json = json.loads(policy['Policy'])
                        
                        for statement in policy_json.get('Statement', []):
                            if statement.get('Effect') == 'Allow':
                                principal = statement.get('Principal', {})
                                if principal == '*' or 'AWS' in principal and '*' in principal['AWS']:
                                    self.results.append(CloudMisconfig(
                                        service="S3",
                                        resource=bucket_name,
                                        misconfiguration="Overly Permissive Bucket Policy",
                                        risk="HIGH",
                                        evidence=f"Policy allows: {statement.get('Action', 'Unknown')}",
                                        exploitation=f"aws s3 sync s3://{bucket_name} ./downloads/ --no-sign-request"
                                    ))
                    except ClientError:
                        pass
                    
                    # Check if bucket is listable
                    try:
                        s3.list_objects_v2(Bucket=bucket_name, MaxKeys=1)
                        self.results.append(CloudMisconfig(
                            service="S3",
                            resource=bucket_name,
                            misconfiguration="Listable Bucket",
                            risk="MEDIUM",
                            evidence="Bucket allows listing objects without authentication",
                            exploitation=f"aws s3 ls s3://{bucket_name}/ --no-sign-request"
                        ))
                    except ClientError:
                        pass
                        
                except ClientError as e:
                    continue
        
        except Exception as e:
            print(f"[-] S3 scanning error: {e}")
    
    def scan_aws_iam(self):
        """Scan for IAM misconfigurations"""
        print("[*] Scanning AWS IAM for misconfigurations...")
        
        try:
            iam = self.aws_session.client('iam')
            
            # Get current user/role
            sts = self.aws_session.client('sts')
            identity = sts.get_caller_identity()
            
            # List users
            users = iam.list_users()
            for user in users['Users']:
                user_name = user['UserName']
                
                # Check for access keys
                try:
                    keys = iam.list_access_keys(UserName=user_name)
                    for key in keys['AccessKeyMetadata']:
                        if key['Status'] == 'Active':
                            # Check last used
                            try:
                                last_used = iam.get_access_key_last_used(AccessKeyId=key['AccessKeyId'])
                                if 'LastUsedDate' not in last_used['AccessKeyLastUsed']:
                                    self.results.append(CloudMisconfig(
                                        service="IAM",
                                        resource=user_name,
                                        misconfiguration="Unused Access Key",
                                        risk="MEDIUM",
                                        evidence=f"Access key {key['AccessKeyId']} never used",
                                        exploitation=f"# Use with: AWS_ACCESS_KEY_ID={key['AccessKeyId']} aws s3 ls"
                                    ))
                            except ClientError:
                                pass
                except ClientError:
                    pass
                
                # Check inline policies
                try:
                    policies = iam.list_user_policies(UserName=user_name)
                    for policy_name in policies['PolicyNames']:
                        policy = iam.get_user_policy(UserName=user_name, PolicyName=policy_name)
                        if self._check_permissive_policy(policy['PolicyDocument']):
                            self.results.append(CloudMisconfig(
                                service="IAM",
                                resource=user_name,
                                misconfiguration="Overly Permissive Inline Policy",
                                risk="HIGH",
                                evidence=f"Policy: {policy_name}",
                                exploitation="# Policy allows broad permissions"
                            ))
                except ClientError:
                    pass
            
            # Check roles
            roles = iam.list_roles()
            for role in roles['Roles']:
                role_name = role['RoleName']
                
                # Check trust policy
                trust_policy = role['AssumeRolePolicyDocument']
                if self._check_trust_policy_misconfig(trust_policy):
                    self.results.append(CloudMisconfig(
                        service="IAM",
                        resource=role_name,
                        misconfiguration="Overly Permissive Trust Policy",
                        risk="HIGH",
                        evidence="Trust policy allows assumption from untrusted entities",
                        exploitation=f"aws sts assume-role --role-arn {role['Arn']} --role-session-name test"
                    ))
        
        except Exception as e:
            print(f"[-] IAM scanning error: {e}")
    
    def _check_permissive_policy(self, policy_doc):
        """Check if policy document is overly permissive"""
        for statement in policy_doc.get('Statement', []):
            if statement.get('Effect') == 'Allow':
                actions = statement.get('Action', [])
                if isinstance(actions, str):
                    actions = [actions]
                
                # Check for dangerous permissions
                dangerous_actions = ['*', 'iam:*', 's3:*', 'ec2:*', 'lambda:*']
                for action in actions:
                    if any(da in action for da in dangerous_actions):
                        return True
        return False
    
    def _check_trust_policy_misconfig(self, trust_policy):
        """Check for trust policy misconfigurations"""
        for statement in trust_policy.get('Statement', []):
            if statement.get('Effect') == 'Allow':
                principal = statement.get('Principal', {})
                if 'AWS' in principal and principal['AWS'] == '*':
                    return True
                if 'Service' in principal and 'lambda.amazonaws.com' in principal['Service']:
                    # Could be abused via lambda role assumption
                    return True
        return False
    
    def scan_aws_ec2(self):
        """Scan for EC2 misconfigurations"""
        print("[*] Scanning AWS EC2 for misconfigurations...")
        
        try:
            ec2 = self.aws_session.client('ec2')
            
            # Describe security groups
            sgs = ec2.describe_security_groups()
            for sg in sgs['SecurityGroups']:
                sg_id = sg['GroupId']
                
                # Check inbound rules
                for permission in sg.get('IpPermissions', []):
                    for ip_range in permission.get('IpRanges', []):
                        if ip_range.get('CidrIp') == '0.0.0.0/0':
                            # Check port ranges
                            from_port = permission.get('FromPort')
                            to_port = permission.get('ToPort')
                            
                            if from_port == 22 or to_port == 22:
                                self.results.append(CloudMisconfig(
                                    service="EC2",
                                    resource=sg_id,
                                    misconfiguration="SSH Open to World",
                                    risk="CRITICAL",
                                    evidence=f"SSH port open from 0.0.0.0/0",
                                    exploitation=f"ssh -i key.pem ec2-user@<instance-ip>"
                                ))
                            elif from_port == 3389 or to_port == 3389:
                                self.results.append(CloudMisconfig(
                                    service="EC2",
                                    resource=sg_id,
                                    misconfiguration="RDP Open to World",
                                    risk="CRITICAL",
                                    evidence=f"RDP port open from 0.0.0.0/0",
                                    exploitation="Use RDP client to connect"
                                ))
                            elif from_port == 80 or to_port == 80 or from_port == 443 or to_port == 443:
                                self.results.append(CloudMisconfig(
                                    service="EC2",
                                    resource=sg_id,
                                    misconfiguration="Web Ports Open to World",
                                    risk="MEDIUM",
                                    evidence=f"Port {from_port}-{to_port} open from 0.0.0.0/0",
                                    exploitation="Access via web browser"
                                ))
            
            # Check for public AMIs
            images = ec2.describe_images(Owners=['self'])
            for image in images['Images']:
                if image.get('Public'):
                    self.results.append(CloudMisconfig(
                        service="EC2",
                        resource=image['ImageId'],
                        misconfiguration="Public AMI",
                        risk="MEDIUM",
                        evidence="AMI is publicly accessible",
                        exploitation=f"aws ec2 run-instances --image-id {image['ImageId']}"
                    ))
        
        except Exception as e:
            print(f"[-] EC2 scanning error: {e}")
    
    def scan_azure_storage(self):
        """Scan for Azure Storage misconfigurations"""
        if not self.azure_credential:
            return
            
        print("[*] Scanning Azure Storage for misconfigurations...")
        
        try:
            from azure.mgmt.storage import StorageManagementClient
            from azure.storage.blob import BlobServiceClient
            
            subscription_id = os.getenv('AZURE_SUBSCRIPTION_ID')
            storage_client = StorageManagementClient(self.azure_credential, subscription_id)
            
            # List storage accounts
            accounts = storage_client.storage_accounts.list()
            
            for account in accounts:
                account_name = account.name
                resource_group = account.id.split('/')[4]
                
                # Get storage account properties
                account_props = storage_client.storage_accounts.get_properties(
                    resource_group, account_name
                )
                
                # Check if blob service allows public access
                if hasattr(account_props, 'allow_blob_public_access') and account_props.allow_blob_public_access:
                    self.results.append(CloudMisconfig(
                        service="Azure Storage",
                        resource=account_name,
                        misconfiguration="Blob Public Access Enabled",
                        risk="HIGH",
                        evidence="Storage account allows public blob access",
                        exploitation=f"az storage blob list --account-name {account_name} --container-name <container> --auth-mode login"
                    ))
                
                # Check network rules
                if hasattr(account_props, 'network_rule_set'):
                    network_rules = account_props.network_rule_set
                    if network_rules.default_action == 'Allow':
                        self.results.append(CloudMisconfig(
                            service="Azure Storage",
                            resource=account_name,
                            misconfiguration="Storage Account Open to Internet",
                            risk="HIGH",
                            evidence="Network rules allow all traffic by default",
                            exploitation="Access storage from any network"
                        ))
        
        except Exception as e:
            print(f"[-] Azure Storage scanning error: {e}")
    
    def scan_gcp_buckets(self):
        """Scan for GCP Storage misconfigurations"""
        if not self.gcp_credentials:
            return
            
        print("[*] Scanning GCP Storage for misconfigurations...")
        
        try:
            storage_client = storage.Client(credentials=self.gcp_credentials)
            
            buckets = storage_client.list_buckets()
            
            for bucket in buckets:
                bucket_name = bucket.name
                
                # Check IAM policy
                policy = bucket.get_iam_policy()
                
                for binding in policy.bindings:
                    if 'allUsers' in binding.members or 'allAuthenticatedUsers' in binding.members:
                        self.results.append(CloudMisconfig(
                            service="GCP Storage",
                            resource=bucket_name,
                            misconfiguration="Public Bucket Access",
                            risk="HIGH",
                            evidence=f"Role {binding.role} granted to {binding.members}",
                            exploitation=f"gsutil ls gs://{bucket_name}/"
                        ))
                
                # Check if bucket is publicly accessible
                try:
                    # Try to list objects without authentication
                    test_url = f"https://storage.googleapis.com/storage/v1/b/{bucket_name}/o"
                    response = requests.get(test_url, timeout=5)
                    if response.status_code == 200:
                        self.results.append(CloudMisconfig(
                            service="GCP Storage",
                            resource=bucket_name,
                            misconfiguration="Publicly Listable Bucket",
                            risk="MEDIUM",
                            evidence="Bucket metadata is publicly accessible",
                            exploitation=f"curl '{test_url}'"
                        ))
                except:
                    pass
        
        except Exception as e:
            print(f"[-] GCP Storage scanning error: {e}")
    
    def scan_public_resources(self):
        """Scan for publicly accessible resources using common patterns"""
        print("[*] Scanning for publicly accessible cloud resources...")
        
        # Common cloud resource patterns
        patterns = [
            # AWS S3
            (r'https?://([a-z0-9.-]+\.)?s3[.-]([a-z0-9-]+)\.amazonaws\.com', 'AWS S3 Bucket'),
            (r'https?://s3\.amazonaws\.com/([a-z0-9.-]+)', 'AWS S3 Bucket'),
            
            # Azure Storage
            (r'https?://([a-z0-9]+)\.blob\.core\.windows\.net', 'Azure Storage Account'),
            (r'https?://([a-z0-9]+)\.file\.core\.windows\.net', 'Azure File Storage'),
            
            # GCP Storage
            (r'https?://storage\.cloudgoogle\.com/([a-z0-9.-]+)', 'GCP Storage Bucket'),
            (r'https?://([a-z0-9.-]+)\.storage\.googleapis\.com', 'GCP Storage Bucket'),
        ]
        
        # Test common endpoints
        test_endpoints = [
            "http://s3.amazonaws.com/[bucket]",
            "https://[account].blob.core.windows.net",
            "https://storage.cloud.google.com/[bucket]"
        ]
        
        # In a real scenario, you'd use wordlists and more sophisticated discovery
        print("    [Note] Public resource scanning requires target-specific wordlists")
    
    def exploit_s3_bucket(self, bucket_name):
        """Attempt to exploit a public S3 bucket"""
        print(f"[*] Attempting to exploit S3 bucket: {bucket_name}")
        
        try:
            # List objects
            s3 = self.aws_session.client('s3')
            objects = s3.list_objects_v2(Bucket=bucket_name)
            
            if 'Contents' in objects:
                print(f"[+] Found {len(objects['Contents'])} objects in bucket")
                
                # Download first few objects for analysis
                for obj in objects['Contents'][:5]:
                    key = obj['Key']
                    print(f"    - {key} (Size: {obj['Size']} bytes)")
                    
                    # Try to download
                    try:
                        response = s3.get_object(Bucket=bucket_name, Key=key)
                        content = response['Body'].read(1024)  # First 1KB
                        
                        # Check for sensitive data patterns
                        sensitive_patterns = [
                            (b'AKIA[0-9A-Z]{16}', 'AWS Access Key'),
                            (b'password', 'Password mention'),
                            (b'secret', 'Secret mention'),
                            (b'private.key', 'Private key'),
                        ]
                        
                        for pattern, description in sensitive_patterns:
                            if re.search(pattern, content, re.IGNORECASE):
                                print(f"    [!] Potential {description} in {key}")
                    
                    except ClientError as e:
                        print(f"    [-] Cannot download {key}: {e}")
            
            return True
            
        except ClientError as e:
            print(f"[-] Cannot access bucket {bucket_name}: {e}")
            return False
    
    def generate_report(self):
        """Generate comprehensive misconfiguration report"""
        print("\n" + "="*80)
        print("CLOUD MISCONFIGURATION EXPLOITATION REPORT")
        print("="*80)
        
        if not self.results:
            print("No misconfigurations found!")
            return
        
        # Group by risk level
        risk_levels = {}
        for result in self.results:
            if result.risk not in risk_levels:
                risk_levels[result.risk] = []
            risk_levels[result.risk].append(result)
        
        # Print by risk level
        for risk in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            if risk in risk_levels:
                print(f"\n{risk} RISK FINDINGS ({len(risk_levels[risk])}):")
                print("-" * 50)
                
                for finding in risk_levels[risk]:
                    print(f"\nService: {finding.service}")
                    print(f"Resource: {finding.resource}")
                    print(f"Misconfiguration: {finding.misconfiguration}")
                    print(f"Evidence: {finding.evidence}")
                    if finding.exploitation:
                        print(f"Exploitation: {finding.exploitation}")
                    print("-" * 30)
        
        # Summary
        total = len(self.results)
        critical = len(risk_levels.get('CRITICAL', []))
        high = len(risk_levels.get('HIGH', []))
        
        print(f"\nSUMMARY:")
        print(f"Total Findings: {total}")
        print(f"Critical: {critical}")
        print(f"High: {high}")
        print(f"Medium: {len(risk_levels.get('MEDIUM', []))}")
        print(f"Low: {len(risk_levels.get('LOW', []))}")
    
    def run_full_scan(self):
        """Run complete cloud misconfiguration scan"""
        print("[*] Starting comprehensive cloud misconfiguration scan")
        
        # Initialize cloud providers
        aws_initialized = self.initialize_aws()
        azure_initialized = self.initialize_azure()
        gcp_initialized = self.initialize_gcp()
        
        # AWS Scans
        if aws_initialized:
            self.scan_aws_s3_buckets()
            self.scan_aws_iam()
            self.scan_aws_ec2()
        
        # Azure Scans
        if azure_initialized:
            self.scan_azure_storage()
        
        # GCP Scans
        if gcp_initialized:
            self.scan_gcp_buckets()
        
        # Public resource scanning
        self.scan_public_resources()
        
        # Generate report
        self.generate_report()

def main():
    parser = argparse.ArgumentParser(description='Cloud Misconfiguration Exploitation Toolkit')
    parser.add_argument('--scan', action='store_true', help='Run full misconfiguration scan')
    parser.add_argument('--exploit-s3', help='Exploit specific S3 bucket')
    parser.add_argument('--provider', choices=['aws', 'azure', 'gcp', 'all'], default='all', 
                       help='Cloud provider to scan')
    
    args = parser.parse_args()
    
    exploiter = CloudMisconfigExploiter()
    
    if args.exploit_s3:
        if exploiter.initialize_aws():
            exploiter.exploit_s3_bucket(args.exploit_s3)
    elif args.scan:
        exploiter.run_full_scan()
    else:
        print("Use --scan for full scan or --exploit-s3 <bucket> for specific exploitation")

if __name__ == "__main__":
    main()
