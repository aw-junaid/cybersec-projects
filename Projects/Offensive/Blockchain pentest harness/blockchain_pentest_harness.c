#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <jansson.h>

#define RPC_URL "http://localhost:8545"
#define MAX_REQUEST_SIZE 4096

typedef struct {
    char* data;
    size_t size;
} http_response_t;

// JSON-RPC request structure
typedef struct {
    char* method;
    char* params;
    int id;
} rpc_request_t;

size_t write_callback(void* contents, size_t size, size_t nmemb, http_response_t* response) {
    size_t total_size = size * nmemb;
    response->data = realloc(response->data, response->size + total_size + 1);
    
    if (response->data == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }
    
    memcpy(&(response->data[response->size]), contents, total_size);
    response->size += total_size;
    response->data[response->size] = '\0';
    
    return total_size;
}

char* rpc_call(const char* method, const char* params) {
    CURL* curl;
    CURLcode res;
    
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    
    if (curl) {
        http_response_t response;
        response.data = malloc(1);
        response.size = 0;
        
        // Build JSON-RPC request
        char request[MAX_REQUEST_SIZE];
        snprintf(request, sizeof(request),
                "{\"jsonrpc\":\"2.0\",\"method\":\"%s\",\"params\":%s,\"id\":1}",
                method, params ? params : "[]");
        
        curl_easy_setopt(curl, CURLOPT_URL, RPC_URL);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
        
        res = curl_easy_perform(curl);
        
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            free(response.data);
            response.data = NULL;
        }
        
        curl_easy_cleanup(curl);
        return response.data;
    }
    
    curl_global_cleanup();
    return NULL;
}

void test_blockchain_connection() {
    printf("[*] Testing blockchain connection...\n");
    
    char* response = rpc_call("web3_clientVersion", "[]");
    if (response) {
        json_error_t error;
        json_t* root = json_loads(response, 0, &error);
        
        if (root) {
            json_t* result = json_object_get(root, "result");
            if (result) {
                printf("[+] Connected to: %s\n", json_string_value(result));
            }
            json_decref(root);
        }
        free(response);
    }
}

void get_block_number() {
    printf("[*] Getting current block number...\n");
    
    char* response = rpc_call("eth_blockNumber", "[]");
    if (response) {
        json_error_t error;
        json_t* root = json_loads(response, 0, &error);
        
        if (root) {
            json_t* result = json_object_get(root, "result");
            if (result) {
                printf("[+] Current block: %s\n", json_string_value(result));
            }
            json_decref(root);
        }
        free(response);
    }
}

void get_accounts() {
    printf("[*] Retrieving accounts...\n");
    
    char* response = rpc_call("eth_accounts", "[]");
    if (response) {
        json_error_t error;
        json_t* root = json_loads(response, 0, &error);
        
        if (root) {
            json_t* result = json_object_get(root, "result");
            if (result && json_is_array(result)) {
                size_t index;
                json_t* value;
                
                printf("[+] Found %zd accounts:\n", json_array_size(result));
                json_array_foreach(result, index, value) {
                    printf("    %s\n", json_string_value(value));
                }
            }
            json_decref(root);
        }
        free(response);
    }
}

void call_contract_function(const char* contract_address, const char* data) {
    printf("[*] Calling contract function...\n");
    
    char params[512];
    snprintf(params, sizeof(params),
            "[{\"to\":\"%s\",\"data\":\"%s\"},\"latest\"]",
            contract_address, data);
    
    char* response = rpc_call("eth_call", params);
    if (response) {
        json_error_t error;
        json_t* root = json_loads(response, 0, &error);
        
        if (root) {
            json_t* result = json_object_get(root, "result");
            if (result) {
                printf("[+] Call result: %s\n", json_string_value(result));
            } else {
                json_t* error_obj = json_object_get(root, "error");
                if (error_obj) {
                    printf("[-] Error: %s\n", json_dumps(error_obj, JSON_INDENT(2)));
                }
            }
            json_decref(root);
        }
        free(response);
    }
}

void fuzz_contract_function(const char* contract_address, const char* function_sig) {
    printf("[*] Fuzzing contract function: %s\n", function_sig);
    
    // Simple fuzzing with different input values
    const char* test_inputs[] = {
        "0000000000000000000000000000000000000000000000000000000000000000", // zero
        "0000000000000000000000000000000000000000000000000000000000000001", // one
        "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", // max
        NULL
    };
    
    for (int i = 0; test_inputs[i] != NULL; i++) {
        char data[128];
        snprintf(data, sizeof(data), "%s%s", function_sig, test_inputs[i]);
        
        printf("    Testing input: %s\n", test_inputs[i]);
        call_contract_function(contract_address, data);
    }
}

void interactive_mode() {
    printf("\nBlockchain Pentest Interactive Mode\n");
    printf("Commands: connect, block, accounts, call, fuzz, exit\n\n");
    
    char command[64];
    char address[64];
    char data[128];
    
    while (1) {
        printf("pentest> ");
        
        if (fgets(command, sizeof(command), stdin) == NULL) {
            break;
        }
        
        // Remove newline
        command[strcspn(command, "\n")] = 0;
        
        if (strcmp(command, "exit") == 0) {
            break;
        } else if (strcmp(command, "connect") == 0) {
            test_blockchain_connection();
        } else if (strcmp(command, "block") == 0) {
            get_block_number();
        } else if (strcmp(command, "accounts") == 0) {
            get_accounts();
        } else if (strcmp(command, "call") == 0) {
            printf("Contract address: ");
            fgets(address, sizeof(address), stdin);
            address[strcspn(address, "\n")] = 0;
            
            printf("Call data: ");
            fgets(data, sizeof(data), stdin);
            data[strcspn(data, "\n")] = 0;
            
            call_contract_function(address, data);
        } else if (strcmp(command, "fuzz") == 0) {
            printf("Contract address: ");
            fgets(address, sizeof(address), stdin);
            address[strcspn(address, "\n")] = 0;
            
            printf("Function signature: ");
            fgets(data, sizeof(data), stdin);
            data[strcspn(data, "\n")] = 0;
            
            fuzz_contract_function(address, data);
        } else if (strcmp(command, "help") == 0) {
            printf("Available commands:\n");
            printf("  connect  - Test blockchain connection\n");
            printf("  block    - Get current block number\n");
            printf("  accounts - List available accounts\n");
            printf("  call     - Call contract function\n");
            printf("  fuzz     - Fuzz contract function\n");
            printf("  exit     - Exit interactive mode\n");
        } else {
            printf("Unknown command. Type 'help' for available commands.\n");
        }
    }
}

int main() {
    printf("Blockchain Pentest Harness\n");
    printf("==========================\n");
    
    // Test basic functionality
    test_blockchain_connection();
    get_block_number();
    get_accounts();
    
    // Start interactive mode
    interactive_mode();
    
    return 0;
}
