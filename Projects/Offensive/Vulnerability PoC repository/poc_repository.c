#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlite3.h>
#include <time.h>

#define MAX_VULNERABILITIES 1000
#define MAX_FIELD_LENGTH 256

typedef struct {
    char id[50];
    char cve_id[20];
    char cwe_id[20];
    char name[100];
    char description[500];
    char severity[20];
    char affected_software[500];
    char poc_type[50];
    char risk_level[20];
    char created_date[20];
    char last_tested[20];
} Vulnerability;

typedef struct {
    sqlite3 *db;
    Vulnerability vulnerabilities[MAX_VULNERABILITIES];
    int count;
} PoCRepository;

void initialize_repository(PoCRepository *repo) {
    printf("Initializing Vulnerability PoC Repository...\n");
    
    // Open SQLite database
    int rc = sqlite3_open("vulnerability_pocs.db", &repo->db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(repo->db));
        return;
    }
    
    // Create tables
    const char *create_table_sql = 
        "CREATE TABLE IF NOT EXISTS vulnerabilities ("
        "id TEXT PRIMARY KEY,"
        "cve_id TEXT,"
        "cwe_id TEXT,"
        "name TEXT NOT NULL,"
        "description TEXT,"
        "severity TEXT,"
        "affected_software TEXT,"
        "poc_type TEXT,"
        "risk_level TEXT,"
        "created_date TEXT,"
        "last_tested TEXT"
        ");";
    
    char *err_msg = 0;
    rc = sqlite3_exec(repo->db, create_table_sql, 0, 0, &err_msg);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
    } else {
        printf("Repository initialized successfully\n");
    }
    
    repo->count = 0;
}

void add_vulnerability(PoCRepository *repo, Vulnerability *vuln) {
    // Prepare SQL statement
    const char *insert_sql = 
        "INSERT OR REPLACE INTO vulnerabilities "
        "(id, cve_id, cwe_id, name, description, severity, affected_software, poc_type, risk_level, created_date, last_tested) "
        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(repo->db, insert_sql, -1, &stmt, 0);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(repo->db));
        return;
    }
    
    // Bind parameters
    sqlite3_bind_text(stmt, 1, vuln->id, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, vuln->cve_id, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, vuln->cwe_id, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, vuln->name, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 5, vuln->description, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 6, vuln->severity, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 7, vuln->affected_software, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 8, vuln->poc_type, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 9, vuln->risk_level, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 10, vuln->created_date, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 11, vuln->last_tested, -1, SQLITE_STATIC);
    
    // Execute
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Execution failed: %s\n", sqlite3_errmsg(repo->db));
    } else {
        printf("Added vulnerability: %s\n", vuln->name);
    }
    
    sqlite3_finalize(stmt);
}

void search_vulnerabilities(PoCRepository *repo, const char *search_term) {
    const char *search_sql = 
        "SELECT * FROM vulnerabilities WHERE name LIKE ? OR description LIKE ? OR cve_id LIKE ?;";
    
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(repo->db, search_sql, -1, &stmt, 0);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(repo->db));
        return;
    }
    
    char search_pattern[100];
    snprintf(search_pattern, sizeof(search_pattern), "%%%s%%", search_term);
    
    sqlite3_bind_text(stmt, 1, search_pattern, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, search_pattern, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, search_pattern, -1, SQLITE_STATIC);
    
    printf("\n=== SEARCH RESULTS ===\n");
    int result_count = 0;
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        printf("\nID: %s\n", sqlite3_column_text(stmt, 0));
        printf("CVE: %s\n", sqlite3_column_text(stmt, 1));
        printf("Name: %s\n", sqlite3_column_text(stmt, 3));
        printf("Severity: %s\n", sqlite3_column_text(stmt, 5));
        printf("Description: %s\n", sqlite3_column_text(stmt, 4));
        printf("Last Tested: %s\n", sqlite3_column_text(stmt, 10));
        printf("---\n");
        result_count++;
    }
    
    if (result_count == 0) {
        printf("No vulnerabilities found matching: %s\n", search_term);
    } else {
        printf("Found %d vulnerabilities\n", result_count);
    }
    
    sqlite3_finalize(stmt);
}

void generate_report(PoCRepository *repo) {
    const char *report_sql = "SELECT * FROM vulnerabilities ORDER BY severity DESC;";
    
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(repo->db, report_sql, -1, &stmt, 0);
    
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(repo->db));
        return;
    }
    
    printf("\n=== VULNERABILITY REPORT ===\n");
    printf("Generated: %s\n", __DATE__);
    printf("\n");
    
    int critical_count = 0, high_count = 0, medium_count = 0, low_count = 0;
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        const char *severity = (const char*)sqlite3_column_text(stmt, 5);
        
        if (strcmp(severity, "CRITICAL") == 0) critical_count++;
        else if (strcmp(severity, "HIGH") == 0) high_count++;
        else if (strcmp(severity, "MEDIUM") == 0) medium_count++;
        else if (strcmp(severity, "LOW") == 0) low_count++;
        
        printf("[%s] %s - %s\n", 
               severity,
               (const char*)sqlite3_column_text(stmt, 1),
               (const char*)sqlite3_column_text(stmt, 3));
    }
    
    printf("\n=== SUMMARY ===\n");
    printf("Critical: %d\n", critical_count);
    printf("High: %d\n", high_count);
    printf("Medium: %d\n", medium_count);
    printf("Low: %d\n", low_count);
    printf("Total: %d\n", critical_count + high_count + medium_count + low_count);
    
    sqlite3_finalize(stmt);
}

void add_sample_vulnerabilities(PoCRepository *repo) {
    printf("Adding sample vulnerabilities...\n");
    
    Vulnerability samples[] = {
        {
            "heartbleed-001",
            "CVE-2014-0160",
            "CWE-200",
            "OpenSSL Heartbleed",
            "Information disclosure in OpenSSL TLS heartbeat extension",
            "HIGH",
            "OpenSSL 1.0.1, OpenSSL 1.0.1a, OpenSSL 1.0.1f",
            "information_disclosure",
            "HIGH",
            "2024-01-01",
            "2024-01-01"
        },
        {
            "shellshock-001", 
            "CVE-2014-6271",
            "CWE-78",
            "GNU Bash Shellshock",
            "Remote code execution through bash environment variables",
            "CRITICAL",
            "GNU Bash 4.3, GNU Bash 4.2, GNU Bash 4.1",
            "remote_code_execution", 
            "CRITICAL",
            "2024-01-01",
            "2024-01-01"
        },
        {
            "eternalblue-001",
            "CVE-2017-0144", 
            "CWE-119",
            "EternalBlue SMB Vulnerability",
            "Remote code execution through SMBv1 vulnerability",
            "CRITICAL",
            "Windows 7, Windows Server 2008, Windows XP",
            "remote_code_execution",
            "CRITICAL", 
            "2024-01-01",
            "2024-01-01"
        }
    };
    
    int sample_count = sizeof(samples) / sizeof(Vulnerability);
    for (int i = 0; i < sample_count; i++) {
        add_vulnerability(repo, &samples[i]);
    }
    
    printf("Added %d sample vulnerabilities\n", sample_count);
}

void demonstrate_poc_categories() {
    printf("\n=== VULNERABILITY CATEGORIES ===\n");
    
    printf("\n1. Remote Code Execution (RCE):\n");
    printf("   - Shellshock (CVE-2014-6271)\n");
    printf("   - EternalBlue (CVE-2017-0144)\n");
    printf("   - Log4Shell (CVE-2021-44228)\n");
    
    printf("\n2. Information Disclosure:\n");
    printf("   - Heartbleed (CVE-2014-0160)\n");
    printf("   - Spectre (CVE-2017-5753)\n");
    printf("   - Meltdown (CVE-2017-5754)\n");
    
    printf("\n3. Privilege Escalation:\n");
    printf("   - Dirty COW (CVE-2016-5195)\n");
    printf("   - Sudo Baron Samedit (CVE-2021-3156)\n");
    
    printf("\n4. Denial of Service:\n");
    printf("   - Ping of Death\n");
    printf("   - Teardrop attacks\n");
    printf("   - Slowloris\n");
}

int main() {
    printf("Vulnerability PoC Repository Manager\n");
    printf("====================================\n");
    printf("FOR EDUCATIONAL AND AUTHORIZED TESTING ONLY\n\n");
    
    PoCRepository repo;
    initialize_repository(&repo);
    
    // Add sample data
    add_sample_vulnerabilities(&repo);
    
    // Demonstrate search
    search_vulnerabilities(&repo, "Heartbleed");
    
    // Generate report
    generate_report(&repo);
    
    // Show categories
    demonstrate_poc_categories();
    
    printf("\n=== SECURITY BEST PRACTICES ===\n");
    printf("✅ Always test in isolated environments\n");
    printf("✅ Obtain proper authorization before testing\n");
    printf("✅ Follow responsible disclosure practices\n");
    printf("✅ Keep PoCs updated and documented\n");
    printf("✅ Use version control for all PoC code\n");
    
    sqlite3_close(repo.db);
    return 0;
}
